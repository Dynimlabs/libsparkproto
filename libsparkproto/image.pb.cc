// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: libsparkproto/image.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "libsparkproto/image.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace libspark {
namespace protocol {

namespace {

const ::google::protobuf::Descriptor* ImageMeta_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImageMeta_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImageSetMeta_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImageSetMeta_reflection_ = NULL;
const ::google::protobuf::Descriptor* StreamStartRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StreamStartRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* StreamStopRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StreamStopRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* StreamRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StreamRequest_reflection_ = NULL;
struct StreamRequestOneofInstance {
  const ::libspark::protocol::StreamStartRequest* requeststart_;
  const ::libspark::protocol::StreamStopRequest* requeststop_;
}* StreamRequest_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* StreamResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StreamResponse_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* StreamResponse_ResponseCode_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* SupportedResolution_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ImageFormat_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* StreamType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_libsparkproto_2fimage_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_libsparkproto_2fimage_2eproto() {
  protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "libsparkproto/image.proto");
  GOOGLE_CHECK(file != NULL);
  ImageMeta_descriptor_ = file->message_type(0);
  static const int ImageMeta_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMeta, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMeta, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMeta, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMeta, buffsize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMeta, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMeta, format_),
  };
  ImageMeta_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ImageMeta_descriptor_,
      ImageMeta::default_instance_,
      ImageMeta_offsets_,
      -1,
      -1,
      -1,
      sizeof(ImageMeta),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMeta, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMeta, _is_default_instance_));
  ImageSetMeta_descriptor_ = file->message_type(1);
  static const int ImageSetMeta_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSetMeta, left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSetMeta, right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSetMeta, depth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSetMeta, disparity_),
  };
  ImageSetMeta_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ImageSetMeta_descriptor_,
      ImageSetMeta::default_instance_,
      ImageSetMeta_offsets_,
      -1,
      -1,
      -1,
      sizeof(ImageSetMeta),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSetMeta, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSetMeta, _is_default_instance_));
  StreamStartRequest_descriptor_ = file->message_type(2);
  static const int StreamStartRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamStartRequest, streamtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamStartRequest, imgformat_),
  };
  StreamStartRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StreamStartRequest_descriptor_,
      StreamStartRequest::default_instance_,
      StreamStartRequest_offsets_,
      -1,
      -1,
      -1,
      sizeof(StreamStartRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamStartRequest, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamStartRequest, _is_default_instance_));
  StreamStopRequest_descriptor_ = file->message_type(3);
  static const int StreamStopRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamStopRequest, streamid_),
  };
  StreamStopRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StreamStopRequest_descriptor_,
      StreamStopRequest::default_instance_,
      StreamStopRequest_offsets_,
      -1,
      -1,
      -1,
      sizeof(StreamStopRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamStopRequest, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamStopRequest, _is_default_instance_));
  StreamRequest_descriptor_ = file->message_type(4);
  static const int StreamRequest_offsets_[3] = {
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StreamRequest_default_oneof_instance_, requeststart_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(StreamRequest_default_oneof_instance_, requeststop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamRequest, RequestType_),
  };
  StreamRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StreamRequest_descriptor_,
      StreamRequest::default_instance_,
      StreamRequest_offsets_,
      -1,
      -1,
      -1,
      StreamRequest_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamRequest, _oneof_case_[0]),
      sizeof(StreamRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamRequest, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamRequest, _is_default_instance_));
  StreamResponse_descriptor_ = file->message_type(5);
  static const int StreamResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamResponse, code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamResponse, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamResponse, streamid_),
  };
  StreamResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StreamResponse_descriptor_,
      StreamResponse::default_instance_,
      StreamResponse_offsets_,
      -1,
      -1,
      -1,
      sizeof(StreamResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamResponse, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StreamResponse, _is_default_instance_));
  StreamResponse_ResponseCode_descriptor_ = StreamResponse_descriptor_->enum_type(0);
  SupportedResolution_descriptor_ = file->enum_type(0);
  ImageFormat_descriptor_ = file->enum_type(1);
  StreamType_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_libsparkproto_2fimage_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ImageMeta_descriptor_, &ImageMeta::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ImageSetMeta_descriptor_, &ImageSetMeta::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StreamStartRequest_descriptor_, &StreamStartRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StreamStopRequest_descriptor_, &StreamStopRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StreamRequest_descriptor_, &StreamRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StreamResponse_descriptor_, &StreamResponse::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_libsparkproto_2fimage_2eproto() {
  delete ImageMeta::default_instance_;
  delete ImageMeta_reflection_;
  delete ImageSetMeta::default_instance_;
  delete ImageSetMeta_reflection_;
  delete StreamStartRequest::default_instance_;
  delete StreamStartRequest_reflection_;
  delete StreamStopRequest::default_instance_;
  delete StreamStopRequest_reflection_;
  delete StreamRequest::default_instance_;
  delete StreamRequest_default_oneof_instance_;
  delete StreamRequest_reflection_;
  delete StreamResponse::default_instance_;
  delete StreamResponse_reflection_;
}

void protobuf_AddDesc_libsparkproto_2fimage_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_libsparkproto_2fimage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\031libsparkproto/image.proto\022\021libspark.pr"
    "otocol\"\213\001\n\tImageMeta\022\n\n\002id\030\001 \001(\005\022\r\n\005widt"
    "h\030\002 \001(\005\022\016\n\006height\030\003 \001(\005\022\020\n\010buffsize\030\004 \001("
    "\005\022\021\n\ttimestamp\030\005 \001(\003\022.\n\006format\030\006 \001(\0162\036.l"
    "ibspark.protocol.ImageFormat\"\305\001\n\014ImageSe"
    "tMeta\022*\n\004left\030\001 \001(\0132\034.libspark.protocol."
    "ImageMeta\022+\n\005right\030\002 \001(\0132\034.libspark.prot"
    "ocol.ImageMeta\022+\n\005depth\030\003 \001(\0132\034.libspark"
    ".protocol.ImageMeta\022/\n\tdisparity\030\004 \001(\0132\034"
    ".libspark.protocol.ImageMeta\"[\n\022StreamSt"
    "artRequest\022\022\n\nstreamType\030\001 \001(\r\0221\n\timgFor"
    "mat\030\002 \001(\0162\036.libspark.protocol.ImageForma"
    "t\"%\n\021StreamStopRequest\022\020\n\010streamID\030\001 \001(\005"
    "\"\232\001\n\rStreamRequest\022=\n\014requestStart\030\001 \001(\013"
    "2%.libspark.protocol.StreamStartRequestH"
    "\000\022;\n\013requestStop\030\002 \001(\0132$.libspark.protoc"
    "ol.StreamStopRequestH\000B\r\n\013RequestType\"\320\001"
    "\n\016StreamResponse\022<\n\004code\030\001 \001(\0162..libspar"
    "k.protocol.StreamResponse.ResponseCode\022\017"
    "\n\007message\030\002 \001(\t\022\020\n\010streamID\030\003 \001(\005\"]\n\014Res"
    "ponseCode\022\023\n\017RESPONSE_UNKNOW\020\000\022\017\n\013RESPON"
    "SE_OK\020\001\022\021\n\rRESPONSE_BUSY\020\002\022\024\n\020RESPONSE_F"
    "AILURE\020\003*I\n\023SupportedResolution\022\026\n\022RESOL"
    "UTION_UNKNOWN\020\000\022\032\n\026RESOLUTION_1440W_1080"
    "H\020\001*V\n\013ImageFormat\022\022\n\016FORMAT_UNKNOWN\020\000\022\022"
    "\n\016FORMAT_BAYER10\020\001\022\017\n\013FORMAT_GRAY\020\002\022\016\n\nF"
    "ORMAT_RGB\020\003*k\n\nStreamType\022\022\n\016STREAM_UNKN"
    "OWN\020\000\022\017\n\013STREAM_LEFT\020\001\022\020\n\014STREAM_RIGHT\020\002"
    "\022\020\n\014STREAM_DEPTH\020\004\022\024\n\020STREAM_DISPARITY\020\010"
    "B\002H\001b\006proto3", 1172);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "libsparkproto/image.proto", &protobuf_RegisterTypes);
  ImageMeta::default_instance_ = new ImageMeta();
  ImageSetMeta::default_instance_ = new ImageSetMeta();
  StreamStartRequest::default_instance_ = new StreamStartRequest();
  StreamStopRequest::default_instance_ = new StreamStopRequest();
  StreamRequest::default_instance_ = new StreamRequest();
  StreamRequest_default_oneof_instance_ = new StreamRequestOneofInstance();
  StreamResponse::default_instance_ = new StreamResponse();
  ImageMeta::default_instance_->InitAsDefaultInstance();
  ImageSetMeta::default_instance_->InitAsDefaultInstance();
  StreamStartRequest::default_instance_->InitAsDefaultInstance();
  StreamStopRequest::default_instance_->InitAsDefaultInstance();
  StreamRequest::default_instance_->InitAsDefaultInstance();
  StreamResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_libsparkproto_2fimage_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_libsparkproto_2fimage_2eproto {
  StaticDescriptorInitializer_libsparkproto_2fimage_2eproto() {
    protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  }
} static_descriptor_initializer_libsparkproto_2fimage_2eproto_;
const ::google::protobuf::EnumDescriptor* SupportedResolution_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SupportedResolution_descriptor_;
}
bool SupportedResolution_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ImageFormat_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImageFormat_descriptor_;
}
bool ImageFormat_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StreamType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamType_descriptor_;
}
bool StreamType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ImageMeta::kIdFieldNumber;
const int ImageMeta::kWidthFieldNumber;
const int ImageMeta::kHeightFieldNumber;
const int ImageMeta::kBuffsizeFieldNumber;
const int ImageMeta::kTimestampFieldNumber;
const int ImageMeta::kFormatFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ImageMeta::ImageMeta()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libspark.protocol.ImageMeta)
}

void ImageMeta::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ImageMeta::ImageMeta(const ImageMeta& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libspark.protocol.ImageMeta)
}

void ImageMeta::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  id_ = 0;
  width_ = 0;
  height_ = 0;
  buffsize_ = 0;
  timestamp_ = GOOGLE_LONGLONG(0);
  format_ = 0;
}

ImageMeta::~ImageMeta() {
  // @@protoc_insertion_point(destructor:libspark.protocol.ImageMeta)
  SharedDtor();
}

void ImageMeta::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ImageMeta::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImageMeta::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImageMeta_descriptor_;
}

const ImageMeta& ImageMeta::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  return *default_instance_;
}

ImageMeta* ImageMeta::default_instance_ = NULL;

ImageMeta* ImageMeta::New(::google::protobuf::Arena* arena) const {
  ImageMeta* n = new ImageMeta;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ImageMeta::Clear() {
// @@protoc_insertion_point(message_clear_start:libspark.protocol.ImageMeta)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ImageMeta, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ImageMeta*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(id_, format_);

#undef ZR_HELPER_
#undef ZR_

}

bool ImageMeta::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libspark.protocol.ImageMeta)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_width;
        break;
      }

      // optional int32 width = 2;
      case 2: {
        if (tag == 16) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_height;
        break;
      }

      // optional int32 height = 3;
      case 3: {
        if (tag == 24) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_buffsize;
        break;
      }

      // optional int32 buffsize = 4;
      case 4: {
        if (tag == 32) {
         parse_buffsize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &buffsize_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_timestamp;
        break;
      }

      // optional int64 timestamp = 5;
      case 5: {
        if (tag == 40) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_format;
        break;
      }

      // optional .libspark.protocol.ImageFormat format = 6;
      case 6: {
        if (tag == 48) {
         parse_format:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_format(static_cast< ::libspark::protocol::ImageFormat >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libspark.protocol.ImageMeta)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libspark.protocol.ImageMeta)
  return false;
#undef DO_
}

void ImageMeta::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libspark.protocol.ImageMeta)
  // optional int32 id = 1;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 width = 2;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->width(), output);
  }

  // optional int32 height = 3;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->height(), output);
  }

  // optional int32 buffsize = 4;
  if (this->buffsize() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->buffsize(), output);
  }

  // optional int64 timestamp = 5;
  if (this->timestamp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->timestamp(), output);
  }

  // optional .libspark.protocol.ImageFormat format = 6;
  if (this->format() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->format(), output);
  }

  // @@protoc_insertion_point(serialize_end:libspark.protocol.ImageMeta)
}

::google::protobuf::uint8* ImageMeta::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libspark.protocol.ImageMeta)
  // optional int32 id = 1;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 width = 2;
  if (this->width() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->width(), target);
  }

  // optional int32 height = 3;
  if (this->height() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->height(), target);
  }

  // optional int32 buffsize = 4;
  if (this->buffsize() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->buffsize(), target);
  }

  // optional int64 timestamp = 5;
  if (this->timestamp() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->timestamp(), target);
  }

  // optional .libspark.protocol.ImageFormat format = 6;
  if (this->format() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->format(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:libspark.protocol.ImageMeta)
  return target;
}

int ImageMeta::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:libspark.protocol.ImageMeta)
  int total_size = 0;

  // optional int32 id = 1;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  // optional int32 width = 2;
  if (this->width() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->width());
  }

  // optional int32 height = 3;
  if (this->height() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->height());
  }

  // optional int32 buffsize = 4;
  if (this->buffsize() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->buffsize());
  }

  // optional int64 timestamp = 5;
  if (this->timestamp() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->timestamp());
  }

  // optional .libspark.protocol.ImageFormat format = 6;
  if (this->format() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->format());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageMeta::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:libspark.protocol.ImageMeta)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ImageMeta* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ImageMeta>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:libspark.protocol.ImageMeta)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:libspark.protocol.ImageMeta)
    MergeFrom(*source);
  }
}

void ImageMeta::MergeFrom(const ImageMeta& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:libspark.protocol.ImageMeta)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
  if (from.buffsize() != 0) {
    set_buffsize(from.buffsize());
  }
  if (from.timestamp() != 0) {
    set_timestamp(from.timestamp());
  }
  if (from.format() != 0) {
    set_format(from.format());
  }
}

void ImageMeta::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:libspark.protocol.ImageMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImageMeta::CopyFrom(const ImageMeta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:libspark.protocol.ImageMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageMeta::IsInitialized() const {

  return true;
}

void ImageMeta::Swap(ImageMeta* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ImageMeta::InternalSwap(ImageMeta* other) {
  std::swap(id_, other->id_);
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(buffsize_, other->buffsize_);
  std::swap(timestamp_, other->timestamp_);
  std::swap(format_, other->format_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ImageMeta::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImageMeta_descriptor_;
  metadata.reflection = ImageMeta_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ImageMeta

// optional int32 id = 1;
void ImageMeta::clear_id() {
  id_ = 0;
}
 ::google::protobuf::int32 ImageMeta::id() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.id)
  return id_;
}
 void ImageMeta::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.id)
}

// optional int32 width = 2;
void ImageMeta::clear_width() {
  width_ = 0;
}
 ::google::protobuf::int32 ImageMeta::width() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.width)
  return width_;
}
 void ImageMeta::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.width)
}

// optional int32 height = 3;
void ImageMeta::clear_height() {
  height_ = 0;
}
 ::google::protobuf::int32 ImageMeta::height() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.height)
  return height_;
}
 void ImageMeta::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.height)
}

// optional int32 buffsize = 4;
void ImageMeta::clear_buffsize() {
  buffsize_ = 0;
}
 ::google::protobuf::int32 ImageMeta::buffsize() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.buffsize)
  return buffsize_;
}
 void ImageMeta::set_buffsize(::google::protobuf::int32 value) {
  
  buffsize_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.buffsize)
}

// optional int64 timestamp = 5;
void ImageMeta::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
 ::google::protobuf::int64 ImageMeta::timestamp() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.timestamp)
  return timestamp_;
}
 void ImageMeta::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.timestamp)
}

// optional .libspark.protocol.ImageFormat format = 6;
void ImageMeta::clear_format() {
  format_ = 0;
}
 ::libspark::protocol::ImageFormat ImageMeta::format() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.format)
  return static_cast< ::libspark::protocol::ImageFormat >(format_);
}
 void ImageMeta::set_format(::libspark::protocol::ImageFormat value) {
  
  format_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.format)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ImageSetMeta::kLeftFieldNumber;
const int ImageSetMeta::kRightFieldNumber;
const int ImageSetMeta::kDepthFieldNumber;
const int ImageSetMeta::kDisparityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ImageSetMeta::ImageSetMeta()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libspark.protocol.ImageSetMeta)
}

void ImageSetMeta::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  left_ = const_cast< ::libspark::protocol::ImageMeta*>(&::libspark::protocol::ImageMeta::default_instance());
  right_ = const_cast< ::libspark::protocol::ImageMeta*>(&::libspark::protocol::ImageMeta::default_instance());
  depth_ = const_cast< ::libspark::protocol::ImageMeta*>(&::libspark::protocol::ImageMeta::default_instance());
  disparity_ = const_cast< ::libspark::protocol::ImageMeta*>(&::libspark::protocol::ImageMeta::default_instance());
}

ImageSetMeta::ImageSetMeta(const ImageSetMeta& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libspark.protocol.ImageSetMeta)
}

void ImageSetMeta::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  left_ = NULL;
  right_ = NULL;
  depth_ = NULL;
  disparity_ = NULL;
}

ImageSetMeta::~ImageSetMeta() {
  // @@protoc_insertion_point(destructor:libspark.protocol.ImageSetMeta)
  SharedDtor();
}

void ImageSetMeta::SharedDtor() {
  if (this != default_instance_) {
    delete left_;
    delete right_;
    delete depth_;
    delete disparity_;
  }
}

void ImageSetMeta::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImageSetMeta::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImageSetMeta_descriptor_;
}

const ImageSetMeta& ImageSetMeta::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  return *default_instance_;
}

ImageSetMeta* ImageSetMeta::default_instance_ = NULL;

ImageSetMeta* ImageSetMeta::New(::google::protobuf::Arena* arena) const {
  ImageSetMeta* n = new ImageSetMeta;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ImageSetMeta::Clear() {
// @@protoc_insertion_point(message_clear_start:libspark.protocol.ImageSetMeta)
  if (GetArenaNoVirtual() == NULL && left_ != NULL) delete left_;
  left_ = NULL;
  if (GetArenaNoVirtual() == NULL && right_ != NULL) delete right_;
  right_ = NULL;
  if (GetArenaNoVirtual() == NULL && depth_ != NULL) delete depth_;
  depth_ = NULL;
  if (GetArenaNoVirtual() == NULL && disparity_ != NULL) delete disparity_;
  disparity_ = NULL;
}

bool ImageSetMeta::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libspark.protocol.ImageSetMeta)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .libspark.protocol.ImageMeta left = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_left()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_right;
        break;
      }

      // optional .libspark.protocol.ImageMeta right = 2;
      case 2: {
        if (tag == 18) {
         parse_right:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_right()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_depth;
        break;
      }

      // optional .libspark.protocol.ImageMeta depth = 3;
      case 3: {
        if (tag == 26) {
         parse_depth:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_depth()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_disparity;
        break;
      }

      // optional .libspark.protocol.ImageMeta disparity = 4;
      case 4: {
        if (tag == 34) {
         parse_disparity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_disparity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libspark.protocol.ImageSetMeta)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libspark.protocol.ImageSetMeta)
  return false;
#undef DO_
}

void ImageSetMeta::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libspark.protocol.ImageSetMeta)
  // optional .libspark.protocol.ImageMeta left = 1;
  if (this->has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->left_, output);
  }

  // optional .libspark.protocol.ImageMeta right = 2;
  if (this->has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->right_, output);
  }

  // optional .libspark.protocol.ImageMeta depth = 3;
  if (this->has_depth()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->depth_, output);
  }

  // optional .libspark.protocol.ImageMeta disparity = 4;
  if (this->has_disparity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->disparity_, output);
  }

  // @@protoc_insertion_point(serialize_end:libspark.protocol.ImageSetMeta)
}

::google::protobuf::uint8* ImageSetMeta::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libspark.protocol.ImageSetMeta)
  // optional .libspark.protocol.ImageMeta left = 1;
  if (this->has_left()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->left_, false, target);
  }

  // optional .libspark.protocol.ImageMeta right = 2;
  if (this->has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->right_, false, target);
  }

  // optional .libspark.protocol.ImageMeta depth = 3;
  if (this->has_depth()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->depth_, false, target);
  }

  // optional .libspark.protocol.ImageMeta disparity = 4;
  if (this->has_disparity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->disparity_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:libspark.protocol.ImageSetMeta)
  return target;
}

int ImageSetMeta::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:libspark.protocol.ImageSetMeta)
  int total_size = 0;

  // optional .libspark.protocol.ImageMeta left = 1;
  if (this->has_left()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->left_);
  }

  // optional .libspark.protocol.ImageMeta right = 2;
  if (this->has_right()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->right_);
  }

  // optional .libspark.protocol.ImageMeta depth = 3;
  if (this->has_depth()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->depth_);
  }

  // optional .libspark.protocol.ImageMeta disparity = 4;
  if (this->has_disparity()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->disparity_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageSetMeta::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:libspark.protocol.ImageSetMeta)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ImageSetMeta* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ImageSetMeta>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:libspark.protocol.ImageSetMeta)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:libspark.protocol.ImageSetMeta)
    MergeFrom(*source);
  }
}

void ImageSetMeta::MergeFrom(const ImageSetMeta& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:libspark.protocol.ImageSetMeta)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.has_left()) {
    mutable_left()->::libspark::protocol::ImageMeta::MergeFrom(from.left());
  }
  if (from.has_right()) {
    mutable_right()->::libspark::protocol::ImageMeta::MergeFrom(from.right());
  }
  if (from.has_depth()) {
    mutable_depth()->::libspark::protocol::ImageMeta::MergeFrom(from.depth());
  }
  if (from.has_disparity()) {
    mutable_disparity()->::libspark::protocol::ImageMeta::MergeFrom(from.disparity());
  }
}

void ImageSetMeta::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:libspark.protocol.ImageSetMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImageSetMeta::CopyFrom(const ImageSetMeta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:libspark.protocol.ImageSetMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageSetMeta::IsInitialized() const {

  return true;
}

void ImageSetMeta::Swap(ImageSetMeta* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ImageSetMeta::InternalSwap(ImageSetMeta* other) {
  std::swap(left_, other->left_);
  std::swap(right_, other->right_);
  std::swap(depth_, other->depth_);
  std::swap(disparity_, other->disparity_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ImageSetMeta::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImageSetMeta_descriptor_;
  metadata.reflection = ImageSetMeta_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ImageSetMeta

// optional .libspark.protocol.ImageMeta left = 1;
bool ImageSetMeta::has_left() const {
  return !_is_default_instance_ && left_ != NULL;
}
void ImageSetMeta::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) delete left_;
  left_ = NULL;
}
const ::libspark::protocol::ImageMeta& ImageSetMeta::left() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageSetMeta.left)
  return left_ != NULL ? *left_ : *default_instance_->left_;
}
::libspark::protocol::ImageMeta* ImageSetMeta::mutable_left() {
  
  if (left_ == NULL) {
    left_ = new ::libspark::protocol::ImageMeta;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.ImageSetMeta.left)
  return left_;
}
::libspark::protocol::ImageMeta* ImageSetMeta::release_left() {
  // @@protoc_insertion_point(field_release:libspark.protocol.ImageSetMeta.left)
  
  ::libspark::protocol::ImageMeta* temp = left_;
  left_ = NULL;
  return temp;
}
void ImageSetMeta::set_allocated_left(::libspark::protocol::ImageMeta* left) {
  delete left_;
  left_ = left;
  if (left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.ImageSetMeta.left)
}

// optional .libspark.protocol.ImageMeta right = 2;
bool ImageSetMeta::has_right() const {
  return !_is_default_instance_ && right_ != NULL;
}
void ImageSetMeta::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) delete right_;
  right_ = NULL;
}
const ::libspark::protocol::ImageMeta& ImageSetMeta::right() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageSetMeta.right)
  return right_ != NULL ? *right_ : *default_instance_->right_;
}
::libspark::protocol::ImageMeta* ImageSetMeta::mutable_right() {
  
  if (right_ == NULL) {
    right_ = new ::libspark::protocol::ImageMeta;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.ImageSetMeta.right)
  return right_;
}
::libspark::protocol::ImageMeta* ImageSetMeta::release_right() {
  // @@protoc_insertion_point(field_release:libspark.protocol.ImageSetMeta.right)
  
  ::libspark::protocol::ImageMeta* temp = right_;
  right_ = NULL;
  return temp;
}
void ImageSetMeta::set_allocated_right(::libspark::protocol::ImageMeta* right) {
  delete right_;
  right_ = right;
  if (right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.ImageSetMeta.right)
}

// optional .libspark.protocol.ImageMeta depth = 3;
bool ImageSetMeta::has_depth() const {
  return !_is_default_instance_ && depth_ != NULL;
}
void ImageSetMeta::clear_depth() {
  if (GetArenaNoVirtual() == NULL && depth_ != NULL) delete depth_;
  depth_ = NULL;
}
const ::libspark::protocol::ImageMeta& ImageSetMeta::depth() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageSetMeta.depth)
  return depth_ != NULL ? *depth_ : *default_instance_->depth_;
}
::libspark::protocol::ImageMeta* ImageSetMeta::mutable_depth() {
  
  if (depth_ == NULL) {
    depth_ = new ::libspark::protocol::ImageMeta;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.ImageSetMeta.depth)
  return depth_;
}
::libspark::protocol::ImageMeta* ImageSetMeta::release_depth() {
  // @@protoc_insertion_point(field_release:libspark.protocol.ImageSetMeta.depth)
  
  ::libspark::protocol::ImageMeta* temp = depth_;
  depth_ = NULL;
  return temp;
}
void ImageSetMeta::set_allocated_depth(::libspark::protocol::ImageMeta* depth) {
  delete depth_;
  depth_ = depth;
  if (depth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.ImageSetMeta.depth)
}

// optional .libspark.protocol.ImageMeta disparity = 4;
bool ImageSetMeta::has_disparity() const {
  return !_is_default_instance_ && disparity_ != NULL;
}
void ImageSetMeta::clear_disparity() {
  if (GetArenaNoVirtual() == NULL && disparity_ != NULL) delete disparity_;
  disparity_ = NULL;
}
const ::libspark::protocol::ImageMeta& ImageSetMeta::disparity() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageSetMeta.disparity)
  return disparity_ != NULL ? *disparity_ : *default_instance_->disparity_;
}
::libspark::protocol::ImageMeta* ImageSetMeta::mutable_disparity() {
  
  if (disparity_ == NULL) {
    disparity_ = new ::libspark::protocol::ImageMeta;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.ImageSetMeta.disparity)
  return disparity_;
}
::libspark::protocol::ImageMeta* ImageSetMeta::release_disparity() {
  // @@protoc_insertion_point(field_release:libspark.protocol.ImageSetMeta.disparity)
  
  ::libspark::protocol::ImageMeta* temp = disparity_;
  disparity_ = NULL;
  return temp;
}
void ImageSetMeta::set_allocated_disparity(::libspark::protocol::ImageMeta* disparity) {
  delete disparity_;
  disparity_ = disparity;
  if (disparity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.ImageSetMeta.disparity)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StreamStartRequest::kStreamTypeFieldNumber;
const int StreamStartRequest::kImgFormatFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StreamStartRequest::StreamStartRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libspark.protocol.StreamStartRequest)
}

void StreamStartRequest::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

StreamStartRequest::StreamStartRequest(const StreamStartRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libspark.protocol.StreamStartRequest)
}

void StreamStartRequest::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  streamtype_ = 0u;
  imgformat_ = 0;
}

StreamStartRequest::~StreamStartRequest() {
  // @@protoc_insertion_point(destructor:libspark.protocol.StreamStartRequest)
  SharedDtor();
}

void StreamStartRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StreamStartRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StreamStartRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamStartRequest_descriptor_;
}

const StreamStartRequest& StreamStartRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  return *default_instance_;
}

StreamStartRequest* StreamStartRequest::default_instance_ = NULL;

StreamStartRequest* StreamStartRequest::New(::google::protobuf::Arena* arena) const {
  StreamStartRequest* n = new StreamStartRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StreamStartRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:libspark.protocol.StreamStartRequest)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(StreamStartRequest, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<StreamStartRequest*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(streamtype_, imgformat_);

#undef ZR_HELPER_
#undef ZR_

}

bool StreamStartRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libspark.protocol.StreamStartRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 streamType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &streamtype_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_imgFormat;
        break;
      }

      // optional .libspark.protocol.ImageFormat imgFormat = 2;
      case 2: {
        if (tag == 16) {
         parse_imgFormat:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_imgformat(static_cast< ::libspark::protocol::ImageFormat >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libspark.protocol.StreamStartRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libspark.protocol.StreamStartRequest)
  return false;
#undef DO_
}

void StreamStartRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libspark.protocol.StreamStartRequest)
  // optional uint32 streamType = 1;
  if (this->streamtype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->streamtype(), output);
  }

  // optional .libspark.protocol.ImageFormat imgFormat = 2;
  if (this->imgformat() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->imgformat(), output);
  }

  // @@protoc_insertion_point(serialize_end:libspark.protocol.StreamStartRequest)
}

::google::protobuf::uint8* StreamStartRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libspark.protocol.StreamStartRequest)
  // optional uint32 streamType = 1;
  if (this->streamtype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->streamtype(), target);
  }

  // optional .libspark.protocol.ImageFormat imgFormat = 2;
  if (this->imgformat() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->imgformat(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:libspark.protocol.StreamStartRequest)
  return target;
}

int StreamStartRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:libspark.protocol.StreamStartRequest)
  int total_size = 0;

  // optional uint32 streamType = 1;
  if (this->streamtype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->streamtype());
  }

  // optional .libspark.protocol.ImageFormat imgFormat = 2;
  if (this->imgformat() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->imgformat());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StreamStartRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:libspark.protocol.StreamStartRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StreamStartRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StreamStartRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:libspark.protocol.StreamStartRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:libspark.protocol.StreamStartRequest)
    MergeFrom(*source);
  }
}

void StreamStartRequest::MergeFrom(const StreamStartRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:libspark.protocol.StreamStartRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.streamtype() != 0) {
    set_streamtype(from.streamtype());
  }
  if (from.imgformat() != 0) {
    set_imgformat(from.imgformat());
  }
}

void StreamStartRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:libspark.protocol.StreamStartRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StreamStartRequest::CopyFrom(const StreamStartRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:libspark.protocol.StreamStartRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamStartRequest::IsInitialized() const {

  return true;
}

void StreamStartRequest::Swap(StreamStartRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StreamStartRequest::InternalSwap(StreamStartRequest* other) {
  std::swap(streamtype_, other->streamtype_);
  std::swap(imgformat_, other->imgformat_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StreamStartRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StreamStartRequest_descriptor_;
  metadata.reflection = StreamStartRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StreamStartRequest

// optional uint32 streamType = 1;
void StreamStartRequest::clear_streamtype() {
  streamtype_ = 0u;
}
 ::google::protobuf::uint32 StreamStartRequest::streamtype() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamStartRequest.streamType)
  return streamtype_;
}
 void StreamStartRequest::set_streamtype(::google::protobuf::uint32 value) {
  
  streamtype_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamStartRequest.streamType)
}

// optional .libspark.protocol.ImageFormat imgFormat = 2;
void StreamStartRequest::clear_imgformat() {
  imgformat_ = 0;
}
 ::libspark::protocol::ImageFormat StreamStartRequest::imgformat() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamStartRequest.imgFormat)
  return static_cast< ::libspark::protocol::ImageFormat >(imgformat_);
}
 void StreamStartRequest::set_imgformat(::libspark::protocol::ImageFormat value) {
  
  imgformat_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamStartRequest.imgFormat)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StreamStopRequest::kStreamIDFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StreamStopRequest::StreamStopRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libspark.protocol.StreamStopRequest)
}

void StreamStopRequest::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

StreamStopRequest::StreamStopRequest(const StreamStopRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libspark.protocol.StreamStopRequest)
}

void StreamStopRequest::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  streamid_ = 0;
}

StreamStopRequest::~StreamStopRequest() {
  // @@protoc_insertion_point(destructor:libspark.protocol.StreamStopRequest)
  SharedDtor();
}

void StreamStopRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StreamStopRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StreamStopRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamStopRequest_descriptor_;
}

const StreamStopRequest& StreamStopRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  return *default_instance_;
}

StreamStopRequest* StreamStopRequest::default_instance_ = NULL;

StreamStopRequest* StreamStopRequest::New(::google::protobuf::Arena* arena) const {
  StreamStopRequest* n = new StreamStopRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StreamStopRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:libspark.protocol.StreamStopRequest)
  streamid_ = 0;
}

bool StreamStopRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libspark.protocol.StreamStopRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 streamID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &streamid_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libspark.protocol.StreamStopRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libspark.protocol.StreamStopRequest)
  return false;
#undef DO_
}

void StreamStopRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libspark.protocol.StreamStopRequest)
  // optional int32 streamID = 1;
  if (this->streamid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->streamid(), output);
  }

  // @@protoc_insertion_point(serialize_end:libspark.protocol.StreamStopRequest)
}

::google::protobuf::uint8* StreamStopRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libspark.protocol.StreamStopRequest)
  // optional int32 streamID = 1;
  if (this->streamid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->streamid(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:libspark.protocol.StreamStopRequest)
  return target;
}

int StreamStopRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:libspark.protocol.StreamStopRequest)
  int total_size = 0;

  // optional int32 streamID = 1;
  if (this->streamid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->streamid());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StreamStopRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:libspark.protocol.StreamStopRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StreamStopRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StreamStopRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:libspark.protocol.StreamStopRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:libspark.protocol.StreamStopRequest)
    MergeFrom(*source);
  }
}

void StreamStopRequest::MergeFrom(const StreamStopRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:libspark.protocol.StreamStopRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.streamid() != 0) {
    set_streamid(from.streamid());
  }
}

void StreamStopRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:libspark.protocol.StreamStopRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StreamStopRequest::CopyFrom(const StreamStopRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:libspark.protocol.StreamStopRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamStopRequest::IsInitialized() const {

  return true;
}

void StreamStopRequest::Swap(StreamStopRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StreamStopRequest::InternalSwap(StreamStopRequest* other) {
  std::swap(streamid_, other->streamid_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StreamStopRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StreamStopRequest_descriptor_;
  metadata.reflection = StreamStopRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StreamStopRequest

// optional int32 streamID = 1;
void StreamStopRequest::clear_streamid() {
  streamid_ = 0;
}
 ::google::protobuf::int32 StreamStopRequest::streamid() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamStopRequest.streamID)
  return streamid_;
}
 void StreamStopRequest::set_streamid(::google::protobuf::int32 value) {
  
  streamid_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamStopRequest.streamID)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StreamRequest::kRequestStartFieldNumber;
const int StreamRequest::kRequestStopFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StreamRequest::StreamRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libspark.protocol.StreamRequest)
}

void StreamRequest::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  StreamRequest_default_oneof_instance_->requeststart_ = const_cast< ::libspark::protocol::StreamStartRequest*>(&::libspark::protocol::StreamStartRequest::default_instance());
  StreamRequest_default_oneof_instance_->requeststop_ = const_cast< ::libspark::protocol::StreamStopRequest*>(&::libspark::protocol::StreamStopRequest::default_instance());
}

StreamRequest::StreamRequest(const StreamRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libspark.protocol.StreamRequest)
}

void StreamRequest::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  clear_has_RequestType();
}

StreamRequest::~StreamRequest() {
  // @@protoc_insertion_point(destructor:libspark.protocol.StreamRequest)
  SharedDtor();
}

void StreamRequest::SharedDtor() {
  if (has_RequestType()) {
    clear_RequestType();
  }
  if (this != default_instance_) {
  }
}

void StreamRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StreamRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamRequest_descriptor_;
}

const StreamRequest& StreamRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  return *default_instance_;
}

StreamRequest* StreamRequest::default_instance_ = NULL;

StreamRequest* StreamRequest::New(::google::protobuf::Arena* arena) const {
  StreamRequest* n = new StreamRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StreamRequest::clear_RequestType() {
// @@protoc_insertion_point(one_of_clear_start:libspark.protocol.StreamRequest)
  switch(RequestType_case()) {
    case kRequestStart: {
      delete RequestType_.requeststart_;
      break;
    }
    case kRequestStop: {
      delete RequestType_.requeststop_;
      break;
    }
    case REQUESTTYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = REQUESTTYPE_NOT_SET;
}


void StreamRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:libspark.protocol.StreamRequest)
  clear_RequestType();
}

bool StreamRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libspark.protocol.StreamRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .libspark.protocol.StreamStartRequest requestStart = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_requeststart()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_requestStop;
        break;
      }

      // optional .libspark.protocol.StreamStopRequest requestStop = 2;
      case 2: {
        if (tag == 18) {
         parse_requestStop:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_requeststop()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libspark.protocol.StreamRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libspark.protocol.StreamRequest)
  return false;
#undef DO_
}

void StreamRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libspark.protocol.StreamRequest)
  // optional .libspark.protocol.StreamStartRequest requestStart = 1;
  if (has_requeststart()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *RequestType_.requeststart_, output);
  }

  // optional .libspark.protocol.StreamStopRequest requestStop = 2;
  if (has_requeststop()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *RequestType_.requeststop_, output);
  }

  // @@protoc_insertion_point(serialize_end:libspark.protocol.StreamRequest)
}

::google::protobuf::uint8* StreamRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libspark.protocol.StreamRequest)
  // optional .libspark.protocol.StreamStartRequest requestStart = 1;
  if (has_requeststart()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *RequestType_.requeststart_, false, target);
  }

  // optional .libspark.protocol.StreamStopRequest requestStop = 2;
  if (has_requeststop()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *RequestType_.requeststop_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:libspark.protocol.StreamRequest)
  return target;
}

int StreamRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:libspark.protocol.StreamRequest)
  int total_size = 0;

  switch (RequestType_case()) {
    // optional .libspark.protocol.StreamStartRequest requestStart = 1;
    case kRequestStart: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *RequestType_.requeststart_);
      break;
    }
    // optional .libspark.protocol.StreamStopRequest requestStop = 2;
    case kRequestStop: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *RequestType_.requeststop_);
      break;
    }
    case REQUESTTYPE_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StreamRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:libspark.protocol.StreamRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StreamRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StreamRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:libspark.protocol.StreamRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:libspark.protocol.StreamRequest)
    MergeFrom(*source);
  }
}

void StreamRequest::MergeFrom(const StreamRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:libspark.protocol.StreamRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.RequestType_case()) {
    case kRequestStart: {
      mutable_requeststart()->::libspark::protocol::StreamStartRequest::MergeFrom(from.requeststart());
      break;
    }
    case kRequestStop: {
      mutable_requeststop()->::libspark::protocol::StreamStopRequest::MergeFrom(from.requeststop());
      break;
    }
    case REQUESTTYPE_NOT_SET: {
      break;
    }
  }
}

void StreamRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:libspark.protocol.StreamRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StreamRequest::CopyFrom(const StreamRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:libspark.protocol.StreamRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamRequest::IsInitialized() const {

  return true;
}

void StreamRequest::Swap(StreamRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StreamRequest::InternalSwap(StreamRequest* other) {
  std::swap(RequestType_, other->RequestType_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StreamRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StreamRequest_descriptor_;
  metadata.reflection = StreamRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StreamRequest

// optional .libspark.protocol.StreamStartRequest requestStart = 1;
bool StreamRequest::has_requeststart() const {
  return RequestType_case() == kRequestStart;
}
void StreamRequest::set_has_requeststart() {
  _oneof_case_[0] = kRequestStart;
}
void StreamRequest::clear_requeststart() {
  if (has_requeststart()) {
    delete RequestType_.requeststart_;
    clear_has_RequestType();
  }
}
 const ::libspark::protocol::StreamStartRequest& StreamRequest::requeststart() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamRequest.requestStart)
  return has_requeststart()
      ? *RequestType_.requeststart_
      : ::libspark::protocol::StreamStartRequest::default_instance();
}
::libspark::protocol::StreamStartRequest* StreamRequest::mutable_requeststart() {
  if (!has_requeststart()) {
    clear_RequestType();
    set_has_requeststart();
    RequestType_.requeststart_ = new ::libspark::protocol::StreamStartRequest;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.StreamRequest.requestStart)
  return RequestType_.requeststart_;
}
::libspark::protocol::StreamStartRequest* StreamRequest::release_requeststart() {
  // @@protoc_insertion_point(field_release:libspark.protocol.StreamRequest.requestStart)
  if (has_requeststart()) {
    clear_has_RequestType();
    ::libspark::protocol::StreamStartRequest* temp = RequestType_.requeststart_;
    RequestType_.requeststart_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void StreamRequest::set_allocated_requeststart(::libspark::protocol::StreamStartRequest* requeststart) {
  clear_RequestType();
  if (requeststart) {
    set_has_requeststart();
    RequestType_.requeststart_ = requeststart;
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.StreamRequest.requestStart)
}

// optional .libspark.protocol.StreamStopRequest requestStop = 2;
bool StreamRequest::has_requeststop() const {
  return RequestType_case() == kRequestStop;
}
void StreamRequest::set_has_requeststop() {
  _oneof_case_[0] = kRequestStop;
}
void StreamRequest::clear_requeststop() {
  if (has_requeststop()) {
    delete RequestType_.requeststop_;
    clear_has_RequestType();
  }
}
 const ::libspark::protocol::StreamStopRequest& StreamRequest::requeststop() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamRequest.requestStop)
  return has_requeststop()
      ? *RequestType_.requeststop_
      : ::libspark::protocol::StreamStopRequest::default_instance();
}
::libspark::protocol::StreamStopRequest* StreamRequest::mutable_requeststop() {
  if (!has_requeststop()) {
    clear_RequestType();
    set_has_requeststop();
    RequestType_.requeststop_ = new ::libspark::protocol::StreamStopRequest;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.StreamRequest.requestStop)
  return RequestType_.requeststop_;
}
::libspark::protocol::StreamStopRequest* StreamRequest::release_requeststop() {
  // @@protoc_insertion_point(field_release:libspark.protocol.StreamRequest.requestStop)
  if (has_requeststop()) {
    clear_has_RequestType();
    ::libspark::protocol::StreamStopRequest* temp = RequestType_.requeststop_;
    RequestType_.requeststop_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void StreamRequest::set_allocated_requeststop(::libspark::protocol::StreamStopRequest* requeststop) {
  clear_RequestType();
  if (requeststop) {
    set_has_requeststop();
    RequestType_.requeststop_ = requeststop;
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.StreamRequest.requestStop)
}

bool StreamRequest::has_RequestType() const {
  return RequestType_case() != REQUESTTYPE_NOT_SET;
}
void StreamRequest::clear_has_RequestType() {
  _oneof_case_[0] = REQUESTTYPE_NOT_SET;
}
StreamRequest::RequestTypeCase StreamRequest::RequestType_case() const {
  return StreamRequest::RequestTypeCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* StreamResponse_ResponseCode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamResponse_ResponseCode_descriptor_;
}
bool StreamResponse_ResponseCode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const StreamResponse_ResponseCode StreamResponse::RESPONSE_UNKNOW;
const StreamResponse_ResponseCode StreamResponse::RESPONSE_OK;
const StreamResponse_ResponseCode StreamResponse::RESPONSE_BUSY;
const StreamResponse_ResponseCode StreamResponse::RESPONSE_FAILURE;
const StreamResponse_ResponseCode StreamResponse::ResponseCode_MIN;
const StreamResponse_ResponseCode StreamResponse::ResponseCode_MAX;
const int StreamResponse::ResponseCode_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StreamResponse::kCodeFieldNumber;
const int StreamResponse::kMessageFieldNumber;
const int StreamResponse::kStreamIDFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StreamResponse::StreamResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:libspark.protocol.StreamResponse)
}

void StreamResponse::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

StreamResponse::StreamResponse(const StreamResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:libspark.protocol.StreamResponse)
}

void StreamResponse::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  code_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  streamid_ = 0;
}

StreamResponse::~StreamResponse() {
  // @@protoc_insertion_point(destructor:libspark.protocol.StreamResponse)
  SharedDtor();
}

void StreamResponse::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void StreamResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StreamResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamResponse_descriptor_;
}

const StreamResponse& StreamResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  return *default_instance_;
}

StreamResponse* StreamResponse::default_instance_ = NULL;

StreamResponse* StreamResponse::New(::google::protobuf::Arena* arena) const {
  StreamResponse* n = new StreamResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StreamResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:libspark.protocol.StreamResponse)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(StreamResponse, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<StreamResponse*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(code_, streamid_);
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool StreamResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:libspark.protocol.StreamResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .libspark.protocol.StreamResponse.ResponseCode code = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_code(static_cast< ::libspark::protocol::StreamResponse_ResponseCode >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // optional string message = 2;
      case 2: {
        if (tag == 18) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "libspark.protocol.StreamResponse.message"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_streamID;
        break;
      }

      // optional int32 streamID = 3;
      case 3: {
        if (tag == 24) {
         parse_streamID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &streamid_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:libspark.protocol.StreamResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:libspark.protocol.StreamResponse)
  return false;
#undef DO_
}

void StreamResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:libspark.protocol.StreamResponse)
  // optional .libspark.protocol.StreamResponse.ResponseCode code = 1;
  if (this->code() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->code(), output);
  }

  // optional string message = 2;
  if (this->message().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "libspark.protocol.StreamResponse.message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->message(), output);
  }

  // optional int32 streamID = 3;
  if (this->streamid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->streamid(), output);
  }

  // @@protoc_insertion_point(serialize_end:libspark.protocol.StreamResponse)
}

::google::protobuf::uint8* StreamResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:libspark.protocol.StreamResponse)
  // optional .libspark.protocol.StreamResponse.ResponseCode code = 1;
  if (this->code() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->code(), target);
  }

  // optional string message = 2;
  if (this->message().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "libspark.protocol.StreamResponse.message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message(), target);
  }

  // optional int32 streamID = 3;
  if (this->streamid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->streamid(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:libspark.protocol.StreamResponse)
  return target;
}

int StreamResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:libspark.protocol.StreamResponse)
  int total_size = 0;

  // optional .libspark.protocol.StreamResponse.ResponseCode code = 1;
  if (this->code() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->code());
  }

  // optional string message = 2;
  if (this->message().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message());
  }

  // optional int32 streamID = 3;
  if (this->streamid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->streamid());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StreamResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:libspark.protocol.StreamResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StreamResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StreamResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:libspark.protocol.StreamResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:libspark.protocol.StreamResponse)
    MergeFrom(*source);
  }
}

void StreamResponse::MergeFrom(const StreamResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:libspark.protocol.StreamResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.code() != 0) {
    set_code(from.code());
  }
  if (from.message().size() > 0) {

    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  if (from.streamid() != 0) {
    set_streamid(from.streamid());
  }
}

void StreamResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:libspark.protocol.StreamResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StreamResponse::CopyFrom(const StreamResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:libspark.protocol.StreamResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamResponse::IsInitialized() const {

  return true;
}

void StreamResponse::Swap(StreamResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StreamResponse::InternalSwap(StreamResponse* other) {
  std::swap(code_, other->code_);
  message_.Swap(&other->message_);
  std::swap(streamid_, other->streamid_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StreamResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StreamResponse_descriptor_;
  metadata.reflection = StreamResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StreamResponse

// optional .libspark.protocol.StreamResponse.ResponseCode code = 1;
void StreamResponse::clear_code() {
  code_ = 0;
}
 ::libspark::protocol::StreamResponse_ResponseCode StreamResponse::code() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamResponse.code)
  return static_cast< ::libspark::protocol::StreamResponse_ResponseCode >(code_);
}
 void StreamResponse::set_code(::libspark::protocol::StreamResponse_ResponseCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamResponse.code)
}

// optional string message = 2;
void StreamResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& StreamResponse::message() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamResponse.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StreamResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamResponse.message)
}
 void StreamResponse::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.StreamResponse.message)
}
 void StreamResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.StreamResponse.message)
}
 ::std::string* StreamResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.StreamResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* StreamResponse::release_message() {
  // @@protoc_insertion_point(field_release:libspark.protocol.StreamResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StreamResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.StreamResponse.message)
}

// optional int32 streamID = 3;
void StreamResponse::clear_streamid() {
  streamid_ = 0;
}
 ::google::protobuf::int32 StreamResponse::streamid() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamResponse.streamID)
  return streamid_;
}
 void StreamResponse::set_streamid(::google::protobuf::int32 value) {
  
  streamid_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamResponse.streamID)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace libspark

// @@protoc_insertion_point(global_scope)
