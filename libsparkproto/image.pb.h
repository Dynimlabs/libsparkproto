// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: libsparkproto/image.proto

#ifndef PROTOBUF_libsparkproto_2fimage_2eproto__INCLUDED
#define PROTOBUF_libsparkproto_2fimage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace libspark {
namespace protocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_libsparkproto_2fimage_2eproto();
void protobuf_AssignDesc_libsparkproto_2fimage_2eproto();
void protobuf_ShutdownFile_libsparkproto_2fimage_2eproto();

class ImageMeta;
class ImageSetMeta;
class StreamRequest;
class StreamResponse;
class StreamStartRequest;
class StreamStopRequest;

enum StreamResponse_ResponseCode {
  StreamResponse_ResponseCode_RESPONSE_UNKNOW = 0,
  StreamResponse_ResponseCode_RESPONSE_OK = 1,
  StreamResponse_ResponseCode_RESPONSE_BUSY = 2,
  StreamResponse_ResponseCode_RESPONSE_FAILURE = 3,
  StreamResponse_ResponseCode_StreamResponse_ResponseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StreamResponse_ResponseCode_StreamResponse_ResponseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StreamResponse_ResponseCode_IsValid(int value);
const StreamResponse_ResponseCode StreamResponse_ResponseCode_ResponseCode_MIN = StreamResponse_ResponseCode_RESPONSE_UNKNOW;
const StreamResponse_ResponseCode StreamResponse_ResponseCode_ResponseCode_MAX = StreamResponse_ResponseCode_RESPONSE_FAILURE;
const int StreamResponse_ResponseCode_ResponseCode_ARRAYSIZE = StreamResponse_ResponseCode_ResponseCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* StreamResponse_ResponseCode_descriptor();
inline const ::std::string& StreamResponse_ResponseCode_Name(StreamResponse_ResponseCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    StreamResponse_ResponseCode_descriptor(), value);
}
inline bool StreamResponse_ResponseCode_Parse(
    const ::std::string& name, StreamResponse_ResponseCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamResponse_ResponseCode>(
    StreamResponse_ResponseCode_descriptor(), name, value);
}
enum SupportedResolution {
  RESOLUTION_UNKNOWN = 0,
  RESOLUTION_1440W_1080H = 1,
  SupportedResolution_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SupportedResolution_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SupportedResolution_IsValid(int value);
const SupportedResolution SupportedResolution_MIN = RESOLUTION_UNKNOWN;
const SupportedResolution SupportedResolution_MAX = RESOLUTION_1440W_1080H;
const int SupportedResolution_ARRAYSIZE = SupportedResolution_MAX + 1;

const ::google::protobuf::EnumDescriptor* SupportedResolution_descriptor();
inline const ::std::string& SupportedResolution_Name(SupportedResolution value) {
  return ::google::protobuf::internal::NameOfEnum(
    SupportedResolution_descriptor(), value);
}
inline bool SupportedResolution_Parse(
    const ::std::string& name, SupportedResolution* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SupportedResolution>(
    SupportedResolution_descriptor(), name, value);
}
enum ImageFormat {
  FORMAT_UNKNOWN = 0,
  FORMAT_BAYER10 = 1,
  FORMAT_GRAY = 2,
  FORMAT_RGB = 3,
  ImageFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ImageFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ImageFormat_IsValid(int value);
const ImageFormat ImageFormat_MIN = FORMAT_UNKNOWN;
const ImageFormat ImageFormat_MAX = FORMAT_RGB;
const int ImageFormat_ARRAYSIZE = ImageFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageFormat_descriptor();
inline const ::std::string& ImageFormat_Name(ImageFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageFormat_descriptor(), value);
}
inline bool ImageFormat_Parse(
    const ::std::string& name, ImageFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageFormat>(
    ImageFormat_descriptor(), name, value);
}
enum StreamType {
  STREAM_UNKNOWN = 0,
  STREAM_LEFT = 1,
  STREAM_RIGHT = 2,
  STREAM_DEPTH = 4,
  STREAM_DISPARITY = 8,
  StreamType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StreamType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StreamType_IsValid(int value);
const StreamType StreamType_MIN = STREAM_UNKNOWN;
const StreamType StreamType_MAX = STREAM_DISPARITY;
const int StreamType_ARRAYSIZE = StreamType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StreamType_descriptor();
inline const ::std::string& StreamType_Name(StreamType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StreamType_descriptor(), value);
}
inline bool StreamType_Parse(
    const ::std::string& name, StreamType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamType>(
    StreamType_descriptor(), name, value);
}
// ===================================================================

class ImageMeta : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libspark.protocol.ImageMeta) */ {
 public:
  ImageMeta();
  virtual ~ImageMeta();

  ImageMeta(const ImageMeta& from);

  inline ImageMeta& operator=(const ImageMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageMeta& default_instance();

  void Swap(ImageMeta* other);

  // implements Message ----------------------------------------------

  inline ImageMeta* New() const { return New(NULL); }

  ImageMeta* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageMeta& from);
  void MergeFrom(const ImageMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional int32 width = 2;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int32 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // optional int32 buffsize = 4;
  void clear_buffsize();
  static const int kBuffsizeFieldNumber = 4;
  ::google::protobuf::int32 buffsize() const;
  void set_buffsize(::google::protobuf::int32 value);

  // optional int64 timestamp = 5;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // optional .libspark.protocol.ImageFormat format = 6;
  void clear_format();
  static const int kFormatFieldNumber = 6;
  ::libspark::protocol::ImageFormat format() const;
  void set_format(::libspark::protocol::ImageFormat value);

  // @@protoc_insertion_point(class_scope:libspark.protocol.ImageMeta)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 buffsize_;
  ::google::protobuf::int64 timestamp_;
  int format_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_AssignDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_ShutdownFile_libsparkproto_2fimage_2eproto();

  void InitAsDefaultInstance();
  static ImageMeta* default_instance_;
};
// -------------------------------------------------------------------

class ImageSetMeta : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libspark.protocol.ImageSetMeta) */ {
 public:
  ImageSetMeta();
  virtual ~ImageSetMeta();

  ImageSetMeta(const ImageSetMeta& from);

  inline ImageSetMeta& operator=(const ImageSetMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageSetMeta& default_instance();

  void Swap(ImageSetMeta* other);

  // implements Message ----------------------------------------------

  inline ImageSetMeta* New() const { return New(NULL); }

  ImageSetMeta* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageSetMeta& from);
  void MergeFrom(const ImageSetMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageSetMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .libspark.protocol.ImageMeta left = 1;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  const ::libspark::protocol::ImageMeta& left() const;
  ::libspark::protocol::ImageMeta* mutable_left();
  ::libspark::protocol::ImageMeta* release_left();
  void set_allocated_left(::libspark::protocol::ImageMeta* left);

  // optional .libspark.protocol.ImageMeta right = 2;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 2;
  const ::libspark::protocol::ImageMeta& right() const;
  ::libspark::protocol::ImageMeta* mutable_right();
  ::libspark::protocol::ImageMeta* release_right();
  void set_allocated_right(::libspark::protocol::ImageMeta* right);

  // optional .libspark.protocol.ImageMeta depth = 3;
  bool has_depth() const;
  void clear_depth();
  static const int kDepthFieldNumber = 3;
  const ::libspark::protocol::ImageMeta& depth() const;
  ::libspark::protocol::ImageMeta* mutable_depth();
  ::libspark::protocol::ImageMeta* release_depth();
  void set_allocated_depth(::libspark::protocol::ImageMeta* depth);

  // optional .libspark.protocol.ImageMeta disparity = 4;
  bool has_disparity() const;
  void clear_disparity();
  static const int kDisparityFieldNumber = 4;
  const ::libspark::protocol::ImageMeta& disparity() const;
  ::libspark::protocol::ImageMeta* mutable_disparity();
  ::libspark::protocol::ImageMeta* release_disparity();
  void set_allocated_disparity(::libspark::protocol::ImageMeta* disparity);

  // @@protoc_insertion_point(class_scope:libspark.protocol.ImageSetMeta)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::libspark::protocol::ImageMeta* left_;
  ::libspark::protocol::ImageMeta* right_;
  ::libspark::protocol::ImageMeta* depth_;
  ::libspark::protocol::ImageMeta* disparity_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_AssignDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_ShutdownFile_libsparkproto_2fimage_2eproto();

  void InitAsDefaultInstance();
  static ImageSetMeta* default_instance_;
};
// -------------------------------------------------------------------

class StreamStartRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libspark.protocol.StreamStartRequest) */ {
 public:
  StreamStartRequest();
  virtual ~StreamStartRequest();

  StreamStartRequest(const StreamStartRequest& from);

  inline StreamStartRequest& operator=(const StreamStartRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamStartRequest& default_instance();

  void Swap(StreamStartRequest* other);

  // implements Message ----------------------------------------------

  inline StreamStartRequest* New() const { return New(NULL); }

  StreamStartRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamStartRequest& from);
  void MergeFrom(const StreamStartRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamStartRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 streamType = 1;
  void clear_streamtype();
  static const int kStreamTypeFieldNumber = 1;
  ::google::protobuf::uint32 streamtype() const;
  void set_streamtype(::google::protobuf::uint32 value);

  // optional .libspark.protocol.ImageFormat imgFormat = 2;
  void clear_imgformat();
  static const int kImgFormatFieldNumber = 2;
  ::libspark::protocol::ImageFormat imgformat() const;
  void set_imgformat(::libspark::protocol::ImageFormat value);

  // @@protoc_insertion_point(class_scope:libspark.protocol.StreamStartRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 streamtype_;
  int imgformat_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_AssignDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_ShutdownFile_libsparkproto_2fimage_2eproto();

  void InitAsDefaultInstance();
  static StreamStartRequest* default_instance_;
};
// -------------------------------------------------------------------

class StreamStopRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libspark.protocol.StreamStopRequest) */ {
 public:
  StreamStopRequest();
  virtual ~StreamStopRequest();

  StreamStopRequest(const StreamStopRequest& from);

  inline StreamStopRequest& operator=(const StreamStopRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamStopRequest& default_instance();

  void Swap(StreamStopRequest* other);

  // implements Message ----------------------------------------------

  inline StreamStopRequest* New() const { return New(NULL); }

  StreamStopRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamStopRequest& from);
  void MergeFrom(const StreamStopRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamStopRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 streamID = 1;
  void clear_streamid();
  static const int kStreamIDFieldNumber = 1;
  ::google::protobuf::int32 streamid() const;
  void set_streamid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:libspark.protocol.StreamStopRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 streamid_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_AssignDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_ShutdownFile_libsparkproto_2fimage_2eproto();

  void InitAsDefaultInstance();
  static StreamStopRequest* default_instance_;
};
// -------------------------------------------------------------------

class StreamRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libspark.protocol.StreamRequest) */ {
 public:
  StreamRequest();
  virtual ~StreamRequest();

  StreamRequest(const StreamRequest& from);

  inline StreamRequest& operator=(const StreamRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamRequest& default_instance();

  enum RequestTypeCase {
    kRequestStart = 1,
    kRequestStop = 2,
    REQUESTTYPE_NOT_SET = 0,
  };

  void Swap(StreamRequest* other);

  // implements Message ----------------------------------------------

  inline StreamRequest* New() const { return New(NULL); }

  StreamRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamRequest& from);
  void MergeFrom(const StreamRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .libspark.protocol.StreamStartRequest requestStart = 1;
  bool has_requeststart() const;
  void clear_requeststart();
  static const int kRequestStartFieldNumber = 1;
  const ::libspark::protocol::StreamStartRequest& requeststart() const;
  ::libspark::protocol::StreamStartRequest* mutable_requeststart();
  ::libspark::protocol::StreamStartRequest* release_requeststart();
  void set_allocated_requeststart(::libspark::protocol::StreamStartRequest* requeststart);

  // optional .libspark.protocol.StreamStopRequest requestStop = 2;
  bool has_requeststop() const;
  void clear_requeststop();
  static const int kRequestStopFieldNumber = 2;
  const ::libspark::protocol::StreamStopRequest& requeststop() const;
  ::libspark::protocol::StreamStopRequest* mutable_requeststop();
  ::libspark::protocol::StreamStopRequest* release_requeststop();
  void set_allocated_requeststop(::libspark::protocol::StreamStopRequest* requeststop);

  RequestTypeCase RequestType_case() const;
  // @@protoc_insertion_point(class_scope:libspark.protocol.StreamRequest)
 private:
  inline void set_has_requeststart();
  inline void set_has_requeststop();

  inline bool has_RequestType() const;
  void clear_RequestType();
  inline void clear_has_RequestType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union RequestTypeUnion {
    RequestTypeUnion() {}
    ::libspark::protocol::StreamStartRequest* requeststart_;
    ::libspark::protocol::StreamStopRequest* requeststop_;
  } RequestType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_AssignDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_ShutdownFile_libsparkproto_2fimage_2eproto();

  void InitAsDefaultInstance();
  static StreamRequest* default_instance_;
};
// -------------------------------------------------------------------

class StreamResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libspark.protocol.StreamResponse) */ {
 public:
  StreamResponse();
  virtual ~StreamResponse();

  StreamResponse(const StreamResponse& from);

  inline StreamResponse& operator=(const StreamResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamResponse& default_instance();

  void Swap(StreamResponse* other);

  // implements Message ----------------------------------------------

  inline StreamResponse* New() const { return New(NULL); }

  StreamResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamResponse& from);
  void MergeFrom(const StreamResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StreamResponse_ResponseCode ResponseCode;
  static const ResponseCode RESPONSE_UNKNOW =
    StreamResponse_ResponseCode_RESPONSE_UNKNOW;
  static const ResponseCode RESPONSE_OK =
    StreamResponse_ResponseCode_RESPONSE_OK;
  static const ResponseCode RESPONSE_BUSY =
    StreamResponse_ResponseCode_RESPONSE_BUSY;
  static const ResponseCode RESPONSE_FAILURE =
    StreamResponse_ResponseCode_RESPONSE_FAILURE;
  static inline bool ResponseCode_IsValid(int value) {
    return StreamResponse_ResponseCode_IsValid(value);
  }
  static const ResponseCode ResponseCode_MIN =
    StreamResponse_ResponseCode_ResponseCode_MIN;
  static const ResponseCode ResponseCode_MAX =
    StreamResponse_ResponseCode_ResponseCode_MAX;
  static const int ResponseCode_ARRAYSIZE =
    StreamResponse_ResponseCode_ResponseCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseCode_descriptor() {
    return StreamResponse_ResponseCode_descriptor();
  }
  static inline const ::std::string& ResponseCode_Name(ResponseCode value) {
    return StreamResponse_ResponseCode_Name(value);
  }
  static inline bool ResponseCode_Parse(const ::std::string& name,
      ResponseCode* value) {
    return StreamResponse_ResponseCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .libspark.protocol.StreamResponse.ResponseCode code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::libspark::protocol::StreamResponse_ResponseCode code() const;
  void set_code(::libspark::protocol::StreamResponse_ResponseCode value);

  // optional string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional int32 streamID = 3;
  void clear_streamid();
  static const int kStreamIDFieldNumber = 3;
  ::google::protobuf::int32 streamid() const;
  void set_streamid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:libspark.protocol.StreamResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int code_;
  ::google::protobuf::int32 streamid_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_AssignDesc_libsparkproto_2fimage_2eproto();
  friend void protobuf_ShutdownFile_libsparkproto_2fimage_2eproto();

  void InitAsDefaultInstance();
  static StreamResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ImageMeta

// optional int32 id = 1;
inline void ImageMeta::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 ImageMeta::id() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.id)
  return id_;
}
inline void ImageMeta::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.id)
}

// optional int32 width = 2;
inline void ImageMeta::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 ImageMeta::width() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.width)
  return width_;
}
inline void ImageMeta::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.width)
}

// optional int32 height = 3;
inline void ImageMeta::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 ImageMeta::height() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.height)
  return height_;
}
inline void ImageMeta::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.height)
}

// optional int32 buffsize = 4;
inline void ImageMeta::clear_buffsize() {
  buffsize_ = 0;
}
inline ::google::protobuf::int32 ImageMeta::buffsize() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.buffsize)
  return buffsize_;
}
inline void ImageMeta::set_buffsize(::google::protobuf::int32 value) {
  
  buffsize_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.buffsize)
}

// optional int64 timestamp = 5;
inline void ImageMeta::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ImageMeta::timestamp() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.timestamp)
  return timestamp_;
}
inline void ImageMeta::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.timestamp)
}

// optional .libspark.protocol.ImageFormat format = 6;
inline void ImageMeta::clear_format() {
  format_ = 0;
}
inline ::libspark::protocol::ImageFormat ImageMeta::format() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageMeta.format)
  return static_cast< ::libspark::protocol::ImageFormat >(format_);
}
inline void ImageMeta::set_format(::libspark::protocol::ImageFormat value) {
  
  format_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ImageMeta.format)
}

// -------------------------------------------------------------------

// ImageSetMeta

// optional .libspark.protocol.ImageMeta left = 1;
inline bool ImageSetMeta::has_left() const {
  return !_is_default_instance_ && left_ != NULL;
}
inline void ImageSetMeta::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) delete left_;
  left_ = NULL;
}
inline const ::libspark::protocol::ImageMeta& ImageSetMeta::left() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageSetMeta.left)
  return left_ != NULL ? *left_ : *default_instance_->left_;
}
inline ::libspark::protocol::ImageMeta* ImageSetMeta::mutable_left() {
  
  if (left_ == NULL) {
    left_ = new ::libspark::protocol::ImageMeta;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.ImageSetMeta.left)
  return left_;
}
inline ::libspark::protocol::ImageMeta* ImageSetMeta::release_left() {
  // @@protoc_insertion_point(field_release:libspark.protocol.ImageSetMeta.left)
  
  ::libspark::protocol::ImageMeta* temp = left_;
  left_ = NULL;
  return temp;
}
inline void ImageSetMeta::set_allocated_left(::libspark::protocol::ImageMeta* left) {
  delete left_;
  left_ = left;
  if (left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.ImageSetMeta.left)
}

// optional .libspark.protocol.ImageMeta right = 2;
inline bool ImageSetMeta::has_right() const {
  return !_is_default_instance_ && right_ != NULL;
}
inline void ImageSetMeta::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) delete right_;
  right_ = NULL;
}
inline const ::libspark::protocol::ImageMeta& ImageSetMeta::right() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageSetMeta.right)
  return right_ != NULL ? *right_ : *default_instance_->right_;
}
inline ::libspark::protocol::ImageMeta* ImageSetMeta::mutable_right() {
  
  if (right_ == NULL) {
    right_ = new ::libspark::protocol::ImageMeta;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.ImageSetMeta.right)
  return right_;
}
inline ::libspark::protocol::ImageMeta* ImageSetMeta::release_right() {
  // @@protoc_insertion_point(field_release:libspark.protocol.ImageSetMeta.right)
  
  ::libspark::protocol::ImageMeta* temp = right_;
  right_ = NULL;
  return temp;
}
inline void ImageSetMeta::set_allocated_right(::libspark::protocol::ImageMeta* right) {
  delete right_;
  right_ = right;
  if (right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.ImageSetMeta.right)
}

// optional .libspark.protocol.ImageMeta depth = 3;
inline bool ImageSetMeta::has_depth() const {
  return !_is_default_instance_ && depth_ != NULL;
}
inline void ImageSetMeta::clear_depth() {
  if (GetArenaNoVirtual() == NULL && depth_ != NULL) delete depth_;
  depth_ = NULL;
}
inline const ::libspark::protocol::ImageMeta& ImageSetMeta::depth() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageSetMeta.depth)
  return depth_ != NULL ? *depth_ : *default_instance_->depth_;
}
inline ::libspark::protocol::ImageMeta* ImageSetMeta::mutable_depth() {
  
  if (depth_ == NULL) {
    depth_ = new ::libspark::protocol::ImageMeta;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.ImageSetMeta.depth)
  return depth_;
}
inline ::libspark::protocol::ImageMeta* ImageSetMeta::release_depth() {
  // @@protoc_insertion_point(field_release:libspark.protocol.ImageSetMeta.depth)
  
  ::libspark::protocol::ImageMeta* temp = depth_;
  depth_ = NULL;
  return temp;
}
inline void ImageSetMeta::set_allocated_depth(::libspark::protocol::ImageMeta* depth) {
  delete depth_;
  depth_ = depth;
  if (depth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.ImageSetMeta.depth)
}

// optional .libspark.protocol.ImageMeta disparity = 4;
inline bool ImageSetMeta::has_disparity() const {
  return !_is_default_instance_ && disparity_ != NULL;
}
inline void ImageSetMeta::clear_disparity() {
  if (GetArenaNoVirtual() == NULL && disparity_ != NULL) delete disparity_;
  disparity_ = NULL;
}
inline const ::libspark::protocol::ImageMeta& ImageSetMeta::disparity() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ImageSetMeta.disparity)
  return disparity_ != NULL ? *disparity_ : *default_instance_->disparity_;
}
inline ::libspark::protocol::ImageMeta* ImageSetMeta::mutable_disparity() {
  
  if (disparity_ == NULL) {
    disparity_ = new ::libspark::protocol::ImageMeta;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.ImageSetMeta.disparity)
  return disparity_;
}
inline ::libspark::protocol::ImageMeta* ImageSetMeta::release_disparity() {
  // @@protoc_insertion_point(field_release:libspark.protocol.ImageSetMeta.disparity)
  
  ::libspark::protocol::ImageMeta* temp = disparity_;
  disparity_ = NULL;
  return temp;
}
inline void ImageSetMeta::set_allocated_disparity(::libspark::protocol::ImageMeta* disparity) {
  delete disparity_;
  disparity_ = disparity;
  if (disparity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.ImageSetMeta.disparity)
}

// -------------------------------------------------------------------

// StreamStartRequest

// optional uint32 streamType = 1;
inline void StreamStartRequest::clear_streamtype() {
  streamtype_ = 0u;
}
inline ::google::protobuf::uint32 StreamStartRequest::streamtype() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamStartRequest.streamType)
  return streamtype_;
}
inline void StreamStartRequest::set_streamtype(::google::protobuf::uint32 value) {
  
  streamtype_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamStartRequest.streamType)
}

// optional .libspark.protocol.ImageFormat imgFormat = 2;
inline void StreamStartRequest::clear_imgformat() {
  imgformat_ = 0;
}
inline ::libspark::protocol::ImageFormat StreamStartRequest::imgformat() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamStartRequest.imgFormat)
  return static_cast< ::libspark::protocol::ImageFormat >(imgformat_);
}
inline void StreamStartRequest::set_imgformat(::libspark::protocol::ImageFormat value) {
  
  imgformat_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamStartRequest.imgFormat)
}

// -------------------------------------------------------------------

// StreamStopRequest

// optional int32 streamID = 1;
inline void StreamStopRequest::clear_streamid() {
  streamid_ = 0;
}
inline ::google::protobuf::int32 StreamStopRequest::streamid() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamStopRequest.streamID)
  return streamid_;
}
inline void StreamStopRequest::set_streamid(::google::protobuf::int32 value) {
  
  streamid_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamStopRequest.streamID)
}

// -------------------------------------------------------------------

// StreamRequest

// optional .libspark.protocol.StreamStartRequest requestStart = 1;
inline bool StreamRequest::has_requeststart() const {
  return RequestType_case() == kRequestStart;
}
inline void StreamRequest::set_has_requeststart() {
  _oneof_case_[0] = kRequestStart;
}
inline void StreamRequest::clear_requeststart() {
  if (has_requeststart()) {
    delete RequestType_.requeststart_;
    clear_has_RequestType();
  }
}
inline  const ::libspark::protocol::StreamStartRequest& StreamRequest::requeststart() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamRequest.requestStart)
  return has_requeststart()
      ? *RequestType_.requeststart_
      : ::libspark::protocol::StreamStartRequest::default_instance();
}
inline ::libspark::protocol::StreamStartRequest* StreamRequest::mutable_requeststart() {
  if (!has_requeststart()) {
    clear_RequestType();
    set_has_requeststart();
    RequestType_.requeststart_ = new ::libspark::protocol::StreamStartRequest;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.StreamRequest.requestStart)
  return RequestType_.requeststart_;
}
inline ::libspark::protocol::StreamStartRequest* StreamRequest::release_requeststart() {
  // @@protoc_insertion_point(field_release:libspark.protocol.StreamRequest.requestStart)
  if (has_requeststart()) {
    clear_has_RequestType();
    ::libspark::protocol::StreamStartRequest* temp = RequestType_.requeststart_;
    RequestType_.requeststart_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void StreamRequest::set_allocated_requeststart(::libspark::protocol::StreamStartRequest* requeststart) {
  clear_RequestType();
  if (requeststart) {
    set_has_requeststart();
    RequestType_.requeststart_ = requeststart;
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.StreamRequest.requestStart)
}

// optional .libspark.protocol.StreamStopRequest requestStop = 2;
inline bool StreamRequest::has_requeststop() const {
  return RequestType_case() == kRequestStop;
}
inline void StreamRequest::set_has_requeststop() {
  _oneof_case_[0] = kRequestStop;
}
inline void StreamRequest::clear_requeststop() {
  if (has_requeststop()) {
    delete RequestType_.requeststop_;
    clear_has_RequestType();
  }
}
inline  const ::libspark::protocol::StreamStopRequest& StreamRequest::requeststop() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamRequest.requestStop)
  return has_requeststop()
      ? *RequestType_.requeststop_
      : ::libspark::protocol::StreamStopRequest::default_instance();
}
inline ::libspark::protocol::StreamStopRequest* StreamRequest::mutable_requeststop() {
  if (!has_requeststop()) {
    clear_RequestType();
    set_has_requeststop();
    RequestType_.requeststop_ = new ::libspark::protocol::StreamStopRequest;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.StreamRequest.requestStop)
  return RequestType_.requeststop_;
}
inline ::libspark::protocol::StreamStopRequest* StreamRequest::release_requeststop() {
  // @@protoc_insertion_point(field_release:libspark.protocol.StreamRequest.requestStop)
  if (has_requeststop()) {
    clear_has_RequestType();
    ::libspark::protocol::StreamStopRequest* temp = RequestType_.requeststop_;
    RequestType_.requeststop_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void StreamRequest::set_allocated_requeststop(::libspark::protocol::StreamStopRequest* requeststop) {
  clear_RequestType();
  if (requeststop) {
    set_has_requeststop();
    RequestType_.requeststop_ = requeststop;
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.StreamRequest.requestStop)
}

inline bool StreamRequest::has_RequestType() const {
  return RequestType_case() != REQUESTTYPE_NOT_SET;
}
inline void StreamRequest::clear_has_RequestType() {
  _oneof_case_[0] = REQUESTTYPE_NOT_SET;
}
inline StreamRequest::RequestTypeCase StreamRequest::RequestType_case() const {
  return StreamRequest::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StreamResponse

// optional .libspark.protocol.StreamResponse.ResponseCode code = 1;
inline void StreamResponse::clear_code() {
  code_ = 0;
}
inline ::libspark::protocol::StreamResponse_ResponseCode StreamResponse::code() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamResponse.code)
  return static_cast< ::libspark::protocol::StreamResponse_ResponseCode >(code_);
}
inline void StreamResponse::set_code(::libspark::protocol::StreamResponse_ResponseCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamResponse.code)
}

// optional string message = 2;
inline void StreamResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StreamResponse::message() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamResponse.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamResponse.message)
}
inline void StreamResponse::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.StreamResponse.message)
}
inline void StreamResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.StreamResponse.message)
}
inline ::std::string* StreamResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.StreamResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StreamResponse::release_message() {
  // @@protoc_insertion_point(field_release:libspark.protocol.StreamResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.StreamResponse.message)
}

// optional int32 streamID = 3;
inline void StreamResponse::clear_streamid() {
  streamid_ = 0;
}
inline ::google::protobuf::int32 StreamResponse::streamid() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.StreamResponse.streamID)
  return streamid_;
}
inline void StreamResponse::set_streamid(::google::protobuf::int32 value) {
  
  streamid_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.StreamResponse.streamID)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace libspark

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::libspark::protocol::StreamResponse_ResponseCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libspark::protocol::StreamResponse_ResponseCode>() {
  return ::libspark::protocol::StreamResponse_ResponseCode_descriptor();
}
template <> struct is_proto_enum< ::libspark::protocol::SupportedResolution> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libspark::protocol::SupportedResolution>() {
  return ::libspark::protocol::SupportedResolution_descriptor();
}
template <> struct is_proto_enum< ::libspark::protocol::ImageFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libspark::protocol::ImageFormat>() {
  return ::libspark::protocol::ImageFormat_descriptor();
}
template <> struct is_proto_enum< ::libspark::protocol::StreamType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libspark::protocol::StreamType>() {
  return ::libspark::protocol::StreamType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_libsparkproto_2fimage_2eproto__INCLUDED
