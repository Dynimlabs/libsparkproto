// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: libsparkproto/device.proto

#ifndef PROTOBUF_libsparkproto_2fdevice_2eproto__INCLUDED
#define PROTOBUF_libsparkproto_2fdevice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace libspark {
namespace protocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_libsparkproto_2fdevice_2eproto();
void protobuf_AssignDesc_libsparkproto_2fdevice_2eproto();
void protobuf_ShutdownFile_libsparkproto_2fdevice_2eproto();

class DeviceInfoMessage;
class DiscoveryMessage;
class ProtocolVersion;

enum DeviceStatus {
  DEVICE_UNKNOWN = 0,
  DEVICE_READY = 1,
  DEVICE_ERROR = 2,
  DeviceStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DeviceStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DeviceStatus_IsValid(int value);
const DeviceStatus DeviceStatus_MIN = DEVICE_UNKNOWN;
const DeviceStatus DeviceStatus_MAX = DEVICE_ERROR;
const int DeviceStatus_ARRAYSIZE = DeviceStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceStatus_descriptor();
inline const ::std::string& DeviceStatus_Name(DeviceStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceStatus_descriptor(), value);
}
inline bool DeviceStatus_Parse(
    const ::std::string& name, DeviceStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceStatus>(
    DeviceStatus_descriptor(), name, value);
}
// ===================================================================

class ProtocolVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libspark.protocol.ProtocolVersion) */ {
 public:
  ProtocolVersion();
  virtual ~ProtocolVersion();

  ProtocolVersion(const ProtocolVersion& from);

  inline ProtocolVersion& operator=(const ProtocolVersion& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtocolVersion& default_instance();

  void Swap(ProtocolVersion* other);

  // implements Message ----------------------------------------------

  inline ProtocolVersion* New() const { return New(NULL); }

  ProtocolVersion* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtocolVersion& from);
  void MergeFrom(const ProtocolVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtocolVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 major_ = 1;
  void clear_major_();
  static const int kMajorFieldNumber = 1;
  ::google::protobuf::uint32 major_() const;
  void set_major_(::google::protobuf::uint32 value);

  // optional uint32 minor_ = 2;
  void clear_minor_();
  static const int kMinorFieldNumber = 2;
  ::google::protobuf::uint32 minor_() const;
  void set_minor_(::google::protobuf::uint32 value);

  // optional uint32 patch_ = 3;
  void clear_patch_();
  static const int kPatchFieldNumber = 3;
  ::google::protobuf::uint32 patch_() const;
  void set_patch_(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:libspark.protocol.ProtocolVersion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 major__;
  ::google::protobuf::uint32 minor__;
  ::google::protobuf::uint32 patch__;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_libsparkproto_2fdevice_2eproto();
  friend void protobuf_AssignDesc_libsparkproto_2fdevice_2eproto();
  friend void protobuf_ShutdownFile_libsparkproto_2fdevice_2eproto();

  void InitAsDefaultInstance();
  static ProtocolVersion* default_instance_;
};
// -------------------------------------------------------------------

class DeviceInfoMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libspark.protocol.DeviceInfoMessage) */ {
 public:
  DeviceInfoMessage();
  virtual ~DeviceInfoMessage();

  DeviceInfoMessage(const DeviceInfoMessage& from);

  inline DeviceInfoMessage& operator=(const DeviceInfoMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceInfoMessage& default_instance();

  void Swap(DeviceInfoMessage* other);

  // implements Message ----------------------------------------------

  inline DeviceInfoMessage* New() const { return New(NULL); }

  DeviceInfoMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceInfoMessage& from);
  void MergeFrom(const DeviceInfoMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceInfoMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string deviceName = 1;
  void clear_devicename();
  static const int kDeviceNameFieldNumber = 1;
  const ::std::string& devicename() const;
  void set_devicename(const ::std::string& value);
  void set_devicename(const char* value);
  void set_devicename(const char* value, size_t size);
  ::std::string* mutable_devicename();
  ::std::string* release_devicename();
  void set_allocated_devicename(::std::string* devicename);

  // optional string macAddress = 2;
  void clear_macaddress();
  static const int kMacAddressFieldNumber = 2;
  const ::std::string& macaddress() const;
  void set_macaddress(const ::std::string& value);
  void set_macaddress(const char* value);
  void set_macaddress(const char* value, size_t size);
  ::std::string* mutable_macaddress();
  ::std::string* release_macaddress();
  void set_allocated_macaddress(::std::string* macaddress);

  // optional string ipAddress = 3;
  void clear_ipaddress();
  static const int kIpAddressFieldNumber = 3;
  const ::std::string& ipaddress() const;
  void set_ipaddress(const ::std::string& value);
  void set_ipaddress(const char* value);
  void set_ipaddress(const char* value, size_t size);
  ::std::string* mutable_ipaddress();
  ::std::string* release_ipaddress();
  void set_allocated_ipaddress(::std::string* ipaddress);

  // optional string serialNum = 4;
  void clear_serialnum();
  static const int kSerialNumFieldNumber = 4;
  const ::std::string& serialnum() const;
  void set_serialnum(const ::std::string& value);
  void set_serialnum(const char* value);
  void set_serialnum(const char* value, size_t size);
  ::std::string* mutable_serialnum();
  ::std::string* release_serialnum();
  void set_allocated_serialnum(::std::string* serialnum);

  // optional string lenType = 5;
  void clear_lentype();
  static const int kLenTypeFieldNumber = 5;
  const ::std::string& lentype() const;
  void set_lentype(const ::std::string& value);
  void set_lentype(const char* value);
  void set_lentype(const char* value, size_t size);
  ::std::string* mutable_lentype();
  ::std::string* release_lentype();
  void set_allocated_lentype(::std::string* lentype);

  // optional string imuType = 6;
  void clear_imutype();
  static const int kImuTypeFieldNumber = 6;
  const ::std::string& imutype() const;
  void set_imutype(const ::std::string& value);
  void set_imutype(const char* value);
  void set_imutype(const char* value, size_t size);
  ::std::string* mutable_imutype();
  ::std::string* release_imutype();
  void set_allocated_imutype(::std::string* imutype);

  // optional string gnssType = 7;
  void clear_gnsstype();
  static const int kGnssTypeFieldNumber = 7;
  const ::std::string& gnsstype() const;
  void set_gnsstype(const ::std::string& value);
  void set_gnsstype(const char* value);
  void set_gnsstype(const char* value, size_t size);
  ::std::string* mutable_gnsstype();
  ::std::string* release_gnsstype();
  void set_allocated_gnsstype(::std::string* gnsstype);

  // optional .libspark.protocol.ProtocolVersion protocolVersion = 8;
  bool has_protocolversion() const;
  void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 8;
  const ::libspark::protocol::ProtocolVersion& protocolversion() const;
  ::libspark::protocol::ProtocolVersion* mutable_protocolversion();
  ::libspark::protocol::ProtocolVersion* release_protocolversion();
  void set_allocated_protocolversion(::libspark::protocol::ProtocolVersion* protocolversion);

  // optional string firmwareVersion = 9;
  void clear_firmwareversion();
  static const int kFirmwareVersionFieldNumber = 9;
  const ::std::string& firmwareversion() const;
  void set_firmwareversion(const ::std::string& value);
  void set_firmwareversion(const char* value);
  void set_firmwareversion(const char* value, size_t size);
  ::std::string* mutable_firmwareversion();
  ::std::string* release_firmwareversion();
  void set_allocated_firmwareversion(::std::string* firmwareversion);

  // optional string ledType = 10;
  void clear_ledtype();
  static const int kLedTypeFieldNumber = 10;
  const ::std::string& ledtype() const;
  void set_ledtype(const ::std::string& value);
  void set_ledtype(const char* value);
  void set_ledtype(const char* value, size_t size);
  ::std::string* mutable_ledtype();
  ::std::string* release_ledtype();
  void set_allocated_ledtype(::std::string* ledtype);

  // optional string model = 11;
  void clear_model();
  static const int kModelFieldNumber = 11;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  // optional float baseline = 12;
  void clear_baseline();
  static const int kBaselineFieldNumber = 12;
  float baseline() const;
  void set_baseline(float value);

  // optional bool color = 13;
  void clear_color();
  static const int kColorFieldNumber = 13;
  bool color() const;
  void set_color(bool value);

  // optional .libspark.protocol.DeviceStatus status = 14;
  void clear_status();
  static const int kStatusFieldNumber = 14;
  ::libspark::protocol::DeviceStatus status() const;
  void set_status(::libspark::protocol::DeviceStatus value);

  // @@protoc_insertion_point(class_scope:libspark.protocol.DeviceInfoMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr devicename_;
  ::google::protobuf::internal::ArenaStringPtr macaddress_;
  ::google::protobuf::internal::ArenaStringPtr ipaddress_;
  ::google::protobuf::internal::ArenaStringPtr serialnum_;
  ::google::protobuf::internal::ArenaStringPtr lentype_;
  ::google::protobuf::internal::ArenaStringPtr imutype_;
  ::google::protobuf::internal::ArenaStringPtr gnsstype_;
  ::libspark::protocol::ProtocolVersion* protocolversion_;
  ::google::protobuf::internal::ArenaStringPtr firmwareversion_;
  ::google::protobuf::internal::ArenaStringPtr ledtype_;
  ::google::protobuf::internal::ArenaStringPtr model_;
  float baseline_;
  bool color_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_libsparkproto_2fdevice_2eproto();
  friend void protobuf_AssignDesc_libsparkproto_2fdevice_2eproto();
  friend void protobuf_ShutdownFile_libsparkproto_2fdevice_2eproto();

  void InitAsDefaultInstance();
  static DeviceInfoMessage* default_instance_;
};
// -------------------------------------------------------------------

class DiscoveryMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libspark.protocol.DiscoveryMessage) */ {
 public:
  DiscoveryMessage();
  virtual ~DiscoveryMessage();

  DiscoveryMessage(const DiscoveryMessage& from);

  inline DiscoveryMessage& operator=(const DiscoveryMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscoveryMessage& default_instance();

  void Swap(DiscoveryMessage* other);

  // implements Message ----------------------------------------------

  inline DiscoveryMessage* New() const { return New(NULL); }

  DiscoveryMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiscoveryMessage& from);
  void MergeFrom(const DiscoveryMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DiscoveryMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string deviceName = 1;
  void clear_devicename();
  static const int kDeviceNameFieldNumber = 1;
  const ::std::string& devicename() const;
  void set_devicename(const ::std::string& value);
  void set_devicename(const char* value);
  void set_devicename(const char* value, size_t size);
  ::std::string* mutable_devicename();
  ::std::string* release_devicename();
  void set_allocated_devicename(::std::string* devicename);

  // optional string model = 2;
  void clear_model();
  static const int kModelFieldNumber = 2;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  // optional string firmwareVersion = 3;
  void clear_firmwareversion();
  static const int kFirmwareVersionFieldNumber = 3;
  const ::std::string& firmwareversion() const;
  void set_firmwareversion(const ::std::string& value);
  void set_firmwareversion(const char* value);
  void set_firmwareversion(const char* value, size_t size);
  ::std::string* mutable_firmwareversion();
  ::std::string* release_firmwareversion();
  void set_allocated_firmwareversion(::std::string* firmwareversion);

  // optional .libspark.protocol.ProtocolVersion protocolVersion = 4;
  bool has_protocolversion() const;
  void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 4;
  const ::libspark::protocol::ProtocolVersion& protocolversion() const;
  ::libspark::protocol::ProtocolVersion* mutable_protocolversion();
  ::libspark::protocol::ProtocolVersion* release_protocolversion();
  void set_allocated_protocolversion(::libspark::protocol::ProtocolVersion* protocolversion);

  // optional .libspark.protocol.DeviceStatus status = 5;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  ::libspark::protocol::DeviceStatus status() const;
  void set_status(::libspark::protocol::DeviceStatus value);

  // @@protoc_insertion_point(class_scope:libspark.protocol.DiscoveryMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr devicename_;
  ::google::protobuf::internal::ArenaStringPtr model_;
  ::google::protobuf::internal::ArenaStringPtr firmwareversion_;
  ::libspark::protocol::ProtocolVersion* protocolversion_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_libsparkproto_2fdevice_2eproto();
  friend void protobuf_AssignDesc_libsparkproto_2fdevice_2eproto();
  friend void protobuf_ShutdownFile_libsparkproto_2fdevice_2eproto();

  void InitAsDefaultInstance();
  static DiscoveryMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ProtocolVersion

// optional uint32 major_ = 1;
inline void ProtocolVersion::clear_major_() {
  major__ = 0u;
}
inline ::google::protobuf::uint32 ProtocolVersion::major_() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ProtocolVersion.major_)
  return major__;
}
inline void ProtocolVersion::set_major_(::google::protobuf::uint32 value) {
  
  major__ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ProtocolVersion.major_)
}

// optional uint32 minor_ = 2;
inline void ProtocolVersion::clear_minor_() {
  minor__ = 0u;
}
inline ::google::protobuf::uint32 ProtocolVersion::minor_() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ProtocolVersion.minor_)
  return minor__;
}
inline void ProtocolVersion::set_minor_(::google::protobuf::uint32 value) {
  
  minor__ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ProtocolVersion.minor_)
}

// optional uint32 patch_ = 3;
inline void ProtocolVersion::clear_patch_() {
  patch__ = 0u;
}
inline ::google::protobuf::uint32 ProtocolVersion::patch_() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.ProtocolVersion.patch_)
  return patch__;
}
inline void ProtocolVersion::set_patch_(::google::protobuf::uint32 value) {
  
  patch__ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.ProtocolVersion.patch_)
}

// -------------------------------------------------------------------

// DeviceInfoMessage

// optional string deviceName = 1;
inline void DeviceInfoMessage::clear_devicename() {
  devicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfoMessage::devicename() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.deviceName)
  return devicename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_devicename(const ::std::string& value) {
  
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.deviceName)
}
inline void DeviceInfoMessage::set_devicename(const char* value) {
  
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DeviceInfoMessage.deviceName)
}
inline void DeviceInfoMessage::set_devicename(const char* value, size_t size) {
  
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DeviceInfoMessage.deviceName)
}
inline ::std::string* DeviceInfoMessage::mutable_devicename() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DeviceInfoMessage.deviceName)
  return devicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfoMessage::release_devicename() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DeviceInfoMessage.deviceName)
  
  return devicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_allocated_devicename(::std::string* devicename) {
  if (devicename != NULL) {
    
  } else {
    
  }
  devicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicename);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DeviceInfoMessage.deviceName)
}

// optional string macAddress = 2;
inline void DeviceInfoMessage::clear_macaddress() {
  macaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfoMessage::macaddress() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.macAddress)
  return macaddress_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_macaddress(const ::std::string& value) {
  
  macaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.macAddress)
}
inline void DeviceInfoMessage::set_macaddress(const char* value) {
  
  macaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DeviceInfoMessage.macAddress)
}
inline void DeviceInfoMessage::set_macaddress(const char* value, size_t size) {
  
  macaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DeviceInfoMessage.macAddress)
}
inline ::std::string* DeviceInfoMessage::mutable_macaddress() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DeviceInfoMessage.macAddress)
  return macaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfoMessage::release_macaddress() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DeviceInfoMessage.macAddress)
  
  return macaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_allocated_macaddress(::std::string* macaddress) {
  if (macaddress != NULL) {
    
  } else {
    
  }
  macaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), macaddress);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DeviceInfoMessage.macAddress)
}

// optional string ipAddress = 3;
inline void DeviceInfoMessage::clear_ipaddress() {
  ipaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfoMessage::ipaddress() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.ipAddress)
  return ipaddress_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_ipaddress(const ::std::string& value) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.ipAddress)
}
inline void DeviceInfoMessage::set_ipaddress(const char* value) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DeviceInfoMessage.ipAddress)
}
inline void DeviceInfoMessage::set_ipaddress(const char* value, size_t size) {
  
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DeviceInfoMessage.ipAddress)
}
inline ::std::string* DeviceInfoMessage::mutable_ipaddress() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DeviceInfoMessage.ipAddress)
  return ipaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfoMessage::release_ipaddress() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DeviceInfoMessage.ipAddress)
  
  return ipaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress != NULL) {
    
  } else {
    
  }
  ipaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipaddress);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DeviceInfoMessage.ipAddress)
}

// optional string serialNum = 4;
inline void DeviceInfoMessage::clear_serialnum() {
  serialnum_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfoMessage::serialnum() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.serialNum)
  return serialnum_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_serialnum(const ::std::string& value) {
  
  serialnum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.serialNum)
}
inline void DeviceInfoMessage::set_serialnum(const char* value) {
  
  serialnum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DeviceInfoMessage.serialNum)
}
inline void DeviceInfoMessage::set_serialnum(const char* value, size_t size) {
  
  serialnum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DeviceInfoMessage.serialNum)
}
inline ::std::string* DeviceInfoMessage::mutable_serialnum() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DeviceInfoMessage.serialNum)
  return serialnum_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfoMessage::release_serialnum() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DeviceInfoMessage.serialNum)
  
  return serialnum_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_allocated_serialnum(::std::string* serialnum) {
  if (serialnum != NULL) {
    
  } else {
    
  }
  serialnum_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serialnum);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DeviceInfoMessage.serialNum)
}

// optional string lenType = 5;
inline void DeviceInfoMessage::clear_lentype() {
  lentype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfoMessage::lentype() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.lenType)
  return lentype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_lentype(const ::std::string& value) {
  
  lentype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.lenType)
}
inline void DeviceInfoMessage::set_lentype(const char* value) {
  
  lentype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DeviceInfoMessage.lenType)
}
inline void DeviceInfoMessage::set_lentype(const char* value, size_t size) {
  
  lentype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DeviceInfoMessage.lenType)
}
inline ::std::string* DeviceInfoMessage::mutable_lentype() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DeviceInfoMessage.lenType)
  return lentype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfoMessage::release_lentype() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DeviceInfoMessage.lenType)
  
  return lentype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_allocated_lentype(::std::string* lentype) {
  if (lentype != NULL) {
    
  } else {
    
  }
  lentype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lentype);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DeviceInfoMessage.lenType)
}

// optional string imuType = 6;
inline void DeviceInfoMessage::clear_imutype() {
  imutype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfoMessage::imutype() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.imuType)
  return imutype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_imutype(const ::std::string& value) {
  
  imutype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.imuType)
}
inline void DeviceInfoMessage::set_imutype(const char* value) {
  
  imutype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DeviceInfoMessage.imuType)
}
inline void DeviceInfoMessage::set_imutype(const char* value, size_t size) {
  
  imutype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DeviceInfoMessage.imuType)
}
inline ::std::string* DeviceInfoMessage::mutable_imutype() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DeviceInfoMessage.imuType)
  return imutype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfoMessage::release_imutype() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DeviceInfoMessage.imuType)
  
  return imutype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_allocated_imutype(::std::string* imutype) {
  if (imutype != NULL) {
    
  } else {
    
  }
  imutype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imutype);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DeviceInfoMessage.imuType)
}

// optional string gnssType = 7;
inline void DeviceInfoMessage::clear_gnsstype() {
  gnsstype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfoMessage::gnsstype() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.gnssType)
  return gnsstype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_gnsstype(const ::std::string& value) {
  
  gnsstype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.gnssType)
}
inline void DeviceInfoMessage::set_gnsstype(const char* value) {
  
  gnsstype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DeviceInfoMessage.gnssType)
}
inline void DeviceInfoMessage::set_gnsstype(const char* value, size_t size) {
  
  gnsstype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DeviceInfoMessage.gnssType)
}
inline ::std::string* DeviceInfoMessage::mutable_gnsstype() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DeviceInfoMessage.gnssType)
  return gnsstype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfoMessage::release_gnsstype() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DeviceInfoMessage.gnssType)
  
  return gnsstype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_allocated_gnsstype(::std::string* gnsstype) {
  if (gnsstype != NULL) {
    
  } else {
    
  }
  gnsstype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gnsstype);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DeviceInfoMessage.gnssType)
}

// optional .libspark.protocol.ProtocolVersion protocolVersion = 8;
inline bool DeviceInfoMessage::has_protocolversion() const {
  return !_is_default_instance_ && protocolversion_ != NULL;
}
inline void DeviceInfoMessage::clear_protocolversion() {
  if (GetArenaNoVirtual() == NULL && protocolversion_ != NULL) delete protocolversion_;
  protocolversion_ = NULL;
}
inline const ::libspark::protocol::ProtocolVersion& DeviceInfoMessage::protocolversion() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.protocolVersion)
  return protocolversion_ != NULL ? *protocolversion_ : *default_instance_->protocolversion_;
}
inline ::libspark::protocol::ProtocolVersion* DeviceInfoMessage::mutable_protocolversion() {
  
  if (protocolversion_ == NULL) {
    protocolversion_ = new ::libspark::protocol::ProtocolVersion;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DeviceInfoMessage.protocolVersion)
  return protocolversion_;
}
inline ::libspark::protocol::ProtocolVersion* DeviceInfoMessage::release_protocolversion() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DeviceInfoMessage.protocolVersion)
  
  ::libspark::protocol::ProtocolVersion* temp = protocolversion_;
  protocolversion_ = NULL;
  return temp;
}
inline void DeviceInfoMessage::set_allocated_protocolversion(::libspark::protocol::ProtocolVersion* protocolversion) {
  delete protocolversion_;
  protocolversion_ = protocolversion;
  if (protocolversion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DeviceInfoMessage.protocolVersion)
}

// optional string firmwareVersion = 9;
inline void DeviceInfoMessage::clear_firmwareversion() {
  firmwareversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfoMessage::firmwareversion() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.firmwareVersion)
  return firmwareversion_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_firmwareversion(const ::std::string& value) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.firmwareVersion)
}
inline void DeviceInfoMessage::set_firmwareversion(const char* value) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DeviceInfoMessage.firmwareVersion)
}
inline void DeviceInfoMessage::set_firmwareversion(const char* value, size_t size) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DeviceInfoMessage.firmwareVersion)
}
inline ::std::string* DeviceInfoMessage::mutable_firmwareversion() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DeviceInfoMessage.firmwareVersion)
  return firmwareversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfoMessage::release_firmwareversion() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DeviceInfoMessage.firmwareVersion)
  
  return firmwareversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_allocated_firmwareversion(::std::string* firmwareversion) {
  if (firmwareversion != NULL) {
    
  } else {
    
  }
  firmwareversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmwareversion);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DeviceInfoMessage.firmwareVersion)
}

// optional string ledType = 10;
inline void DeviceInfoMessage::clear_ledtype() {
  ledtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfoMessage::ledtype() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.ledType)
  return ledtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_ledtype(const ::std::string& value) {
  
  ledtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.ledType)
}
inline void DeviceInfoMessage::set_ledtype(const char* value) {
  
  ledtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DeviceInfoMessage.ledType)
}
inline void DeviceInfoMessage::set_ledtype(const char* value, size_t size) {
  
  ledtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DeviceInfoMessage.ledType)
}
inline ::std::string* DeviceInfoMessage::mutable_ledtype() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DeviceInfoMessage.ledType)
  return ledtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfoMessage::release_ledtype() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DeviceInfoMessage.ledType)
  
  return ledtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_allocated_ledtype(::std::string* ledtype) {
  if (ledtype != NULL) {
    
  } else {
    
  }
  ledtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ledtype);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DeviceInfoMessage.ledType)
}

// optional string model = 11;
inline void DeviceInfoMessage::clear_model() {
  model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfoMessage::model() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.model)
  return model_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_model(const ::std::string& value) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.model)
}
inline void DeviceInfoMessage::set_model(const char* value) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DeviceInfoMessage.model)
}
inline void DeviceInfoMessage::set_model(const char* value, size_t size) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DeviceInfoMessage.model)
}
inline ::std::string* DeviceInfoMessage::mutable_model() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DeviceInfoMessage.model)
  return model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfoMessage::release_model() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DeviceInfoMessage.model)
  
  return model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfoMessage::set_allocated_model(::std::string* model) {
  if (model != NULL) {
    
  } else {
    
  }
  model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DeviceInfoMessage.model)
}

// optional float baseline = 12;
inline void DeviceInfoMessage::clear_baseline() {
  baseline_ = 0;
}
inline float DeviceInfoMessage::baseline() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.baseline)
  return baseline_;
}
inline void DeviceInfoMessage::set_baseline(float value) {
  
  baseline_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.baseline)
}

// optional bool color = 13;
inline void DeviceInfoMessage::clear_color() {
  color_ = false;
}
inline bool DeviceInfoMessage::color() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.color)
  return color_;
}
inline void DeviceInfoMessage::set_color(bool value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.color)
}

// optional .libspark.protocol.DeviceStatus status = 14;
inline void DeviceInfoMessage::clear_status() {
  status_ = 0;
}
inline ::libspark::protocol::DeviceStatus DeviceInfoMessage::status() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DeviceInfoMessage.status)
  return static_cast< ::libspark::protocol::DeviceStatus >(status_);
}
inline void DeviceInfoMessage::set_status(::libspark::protocol::DeviceStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.DeviceInfoMessage.status)
}

// -------------------------------------------------------------------

// DiscoveryMessage

// optional string deviceName = 1;
inline void DiscoveryMessage::clear_devicename() {
  devicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DiscoveryMessage::devicename() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DiscoveryMessage.deviceName)
  return devicename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DiscoveryMessage::set_devicename(const ::std::string& value) {
  
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DiscoveryMessage.deviceName)
}
inline void DiscoveryMessage::set_devicename(const char* value) {
  
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DiscoveryMessage.deviceName)
}
inline void DiscoveryMessage::set_devicename(const char* value, size_t size) {
  
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DiscoveryMessage.deviceName)
}
inline ::std::string* DiscoveryMessage::mutable_devicename() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DiscoveryMessage.deviceName)
  return devicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DiscoveryMessage::release_devicename() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DiscoveryMessage.deviceName)
  
  return devicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DiscoveryMessage::set_allocated_devicename(::std::string* devicename) {
  if (devicename != NULL) {
    
  } else {
    
  }
  devicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicename);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DiscoveryMessage.deviceName)
}

// optional string model = 2;
inline void DiscoveryMessage::clear_model() {
  model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DiscoveryMessage::model() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DiscoveryMessage.model)
  return model_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DiscoveryMessage::set_model(const ::std::string& value) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DiscoveryMessage.model)
}
inline void DiscoveryMessage::set_model(const char* value) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DiscoveryMessage.model)
}
inline void DiscoveryMessage::set_model(const char* value, size_t size) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DiscoveryMessage.model)
}
inline ::std::string* DiscoveryMessage::mutable_model() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DiscoveryMessage.model)
  return model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DiscoveryMessage::release_model() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DiscoveryMessage.model)
  
  return model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DiscoveryMessage::set_allocated_model(::std::string* model) {
  if (model != NULL) {
    
  } else {
    
  }
  model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DiscoveryMessage.model)
}

// optional string firmwareVersion = 3;
inline void DiscoveryMessage::clear_firmwareversion() {
  firmwareversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DiscoveryMessage::firmwareversion() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DiscoveryMessage.firmwareVersion)
  return firmwareversion_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DiscoveryMessage::set_firmwareversion(const ::std::string& value) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libspark.protocol.DiscoveryMessage.firmwareVersion)
}
inline void DiscoveryMessage::set_firmwareversion(const char* value) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libspark.protocol.DiscoveryMessage.firmwareVersion)
}
inline void DiscoveryMessage::set_firmwareversion(const char* value, size_t size) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libspark.protocol.DiscoveryMessage.firmwareVersion)
}
inline ::std::string* DiscoveryMessage::mutable_firmwareversion() {
  
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DiscoveryMessage.firmwareVersion)
  return firmwareversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DiscoveryMessage::release_firmwareversion() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DiscoveryMessage.firmwareVersion)
  
  return firmwareversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DiscoveryMessage::set_allocated_firmwareversion(::std::string* firmwareversion) {
  if (firmwareversion != NULL) {
    
  } else {
    
  }
  firmwareversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmwareversion);
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DiscoveryMessage.firmwareVersion)
}

// optional .libspark.protocol.ProtocolVersion protocolVersion = 4;
inline bool DiscoveryMessage::has_protocolversion() const {
  return !_is_default_instance_ && protocolversion_ != NULL;
}
inline void DiscoveryMessage::clear_protocolversion() {
  if (GetArenaNoVirtual() == NULL && protocolversion_ != NULL) delete protocolversion_;
  protocolversion_ = NULL;
}
inline const ::libspark::protocol::ProtocolVersion& DiscoveryMessage::protocolversion() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DiscoveryMessage.protocolVersion)
  return protocolversion_ != NULL ? *protocolversion_ : *default_instance_->protocolversion_;
}
inline ::libspark::protocol::ProtocolVersion* DiscoveryMessage::mutable_protocolversion() {
  
  if (protocolversion_ == NULL) {
    protocolversion_ = new ::libspark::protocol::ProtocolVersion;
  }
  // @@protoc_insertion_point(field_mutable:libspark.protocol.DiscoveryMessage.protocolVersion)
  return protocolversion_;
}
inline ::libspark::protocol::ProtocolVersion* DiscoveryMessage::release_protocolversion() {
  // @@protoc_insertion_point(field_release:libspark.protocol.DiscoveryMessage.protocolVersion)
  
  ::libspark::protocol::ProtocolVersion* temp = protocolversion_;
  protocolversion_ = NULL;
  return temp;
}
inline void DiscoveryMessage::set_allocated_protocolversion(::libspark::protocol::ProtocolVersion* protocolversion) {
  delete protocolversion_;
  protocolversion_ = protocolversion;
  if (protocolversion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:libspark.protocol.DiscoveryMessage.protocolVersion)
}

// optional .libspark.protocol.DeviceStatus status = 5;
inline void DiscoveryMessage::clear_status() {
  status_ = 0;
}
inline ::libspark::protocol::DeviceStatus DiscoveryMessage::status() const {
  // @@protoc_insertion_point(field_get:libspark.protocol.DiscoveryMessage.status)
  return static_cast< ::libspark::protocol::DeviceStatus >(status_);
}
inline void DiscoveryMessage::set_status(::libspark::protocol::DeviceStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:libspark.protocol.DiscoveryMessage.status)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace libspark

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::libspark::protocol::DeviceStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libspark::protocol::DeviceStatus>() {
  return ::libspark::protocol::DeviceStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_libsparkproto_2fdevice_2eproto__INCLUDED
